<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题 | 野菜收留所</title><meta name="author" content="菜"><meta name="copyright" content="菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  HTML 1.  html5有什么优化 2. 如何理解HTML语义化 3. meta标签   CSS 0. css3有什么优化 1. CSS选择器及优先级 2. position 属性的值有哪些及其区别 3. box-sizing属性 4. CSS 盒子模型 5. BFC（块级格式上下文）和IFC(行级格式化上下) 6. 水平垂直居中 自适应两栏布局 三栏布局   7. 用CSS实现">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://793335974.github.io/79333/2021/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="野菜收留所">
<meta property="og:description" content="[TOC]  HTML 1.  html5有什么优化 2. 如何理解HTML语义化 3. meta标签   CSS 0. css3有什么优化 1. CSS选择器及优先级 2. position 属性的值有哪些及其区别 3. box-sizing属性 4. CSS 盒子模型 5. BFC（块级格式上下文）和IFC(行级格式化上下) 6. 水平垂直居中 自适应两栏布局 三栏布局   7. 用CSS实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.gumengya.com/Api/FjImg?format=image&_t=4">
<meta property="article:published_time" content="2021-01-01T02:00:00.000Z">
<meta property="article:modified_time" content="2024-05-24T07:24:49.857Z">
<meta property="article:author" content="菜">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.gumengya.com/Api/FjImg?format=image&_t=4"><link rel="shortcut icon" href="/79333/img/favicon.png"><link rel="canonical" href="https://793335974.github.io/79333/2021/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect"/><meta/><link rel="stylesheet" href="/79333/css/index.css"><link rel="stylesheet" href="/79333/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=6.5.1"><link rel="stylesheet" href="/79333/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.33" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/79333/',
  algolia: undefined,
  localSearch: {"path":"/79333/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: '/79333/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.11.1',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-24 15:24:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/79333/css/video.css"><script src="/79333/js/video.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/79333/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/79333/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/79333/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/79333/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/79333/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/79333/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/79333/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/79333/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/79333/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/79333/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/79333/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/79333/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/79333/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4')"><nav id="nav"><span id="blog-info"><a href="/79333/" title="野菜收留所"><span class="site-name">野菜收留所</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/79333/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/79333/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/79333/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/79333/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/79333/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/79333/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/79333/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/79333/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/79333/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-01T02:00:00.000Z" title="发表于 2021-01-01 10:00:00">2021-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-24T07:24:49.857Z" title="更新于 2024-05-24 15:24:49">2024-05-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/79333/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>127分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<ul>
<li><a href="#html">HTML</a><ul>
<li><a href="#1--html5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96">1.  html5有什么优化</a></li>
<li><a href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3html%E8%AF%AD%E4%B9%89%E5%8C%96">2. 如何理解HTML语义化</a></li>
<li><a href="#3-meta%E6%A0%87%E7%AD%BE">3. meta标签</a></li>
</ul>
</li>
<li><a href="#css">CSS</a><ul>
<li><a href="#0-css3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96">0. css3有什么优化</a></li>
<li><a href="#1-css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7">1. CSS选择器及优先级</a></li>
<li><a href="#2-position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB">2. position 属性的值有哪些及其区别</a></li>
<li><a href="#3-box-sizing%E5%B1%9E%E6%80%A7">3. box-sizing属性</a></li>
<li><a href="#4-css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B">4. CSS 盒子模型</a></li>
<li><a href="#5-bfc%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8Cifc%E8%A1%8C%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B">5. BFC（块级格式上下文）和IFC(行级格式化上下)</a></li>
<li><a href="#6-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD">6. 水平垂直居中</a><ul>
<li><a href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80">自适应两栏布局</a></li>
<li><a href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80">三栏布局</a></li>
</ul>
</li>
<li><a href="#7-%E7%94%A8css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7">7. 用CSS实现三角符号</a></li>
<li><a href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%E6%9F%A5">8. 常见的布局类型（查）</a></li>
<li><a href="#9-%E6%B5%AE%E5%8A%A8%E6%9F%A5">9. 浮动（查）</a></li>
<li><a href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0">10. 常见的行内元素和块级元素</a></li>
<li><a href="#11-pxemremvwvhrpx%E7%AD%89%E5%8D%95%E4%BD%8D%E7%9A%84%E7%89%B9%E6%80%A7">11. px,em,rem,vw,vh,rpx等单位的特性</a></li>
<li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AFdom%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%9F%A5">12. <strong>什么是DOM事件流？什么是事件委托</strong>(查)</a></li>
<li><a href="#13-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%9F%A5">13. 事件冒泡和事件捕捉有什么区别（查）</a></li>
<li><a href="#14-link%E5%92%8Cimport">14. link和@import</a></li>
<li><a href="#15-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80">15. 响应式布局</a></li>
<li><a href="#16-%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81">16. 元素不可见</a></li>
</ul>
</li>
<li><a href="#js">JS</a><ul>
<li><a href="#0-object%E5%B8%B8%E7%94%A8%E7%9A%84api">0. Object常用的API</a></li>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 基本数据类型</a></li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B">2. 数据类型检测</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数据类型转换：</a></li>
<li><a href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">4. 作用域和作用域链</a></li>
<li><a href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85">5. 什么是闭包</a></li>
<li><a href="#6-this%E7%9A%84%E6%8C%87%E5%90%91">6. this的指向</a></li>
<li><a href="#7-new-%E5%AE%9E%E7%8E%B0">7. new 实现</a></li>
<li><a href="#9--%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB">9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</a></li>
<li><a href="#10-nan--nan%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88">10. <strong><code>NaN === NaN</code>返回什么</strong></a></li>
<li><a href="#11-%E6%89%8B%E5%86%99callapplybind%E6%9F%A5">11. <strong>手写call、apply、bind</strong>（查）</a></li>
<li><a href="#12-%E6%89%A7%E8%A1%8C%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">12. 执行栈和执行上下文</a></li>
<li><a href="#13-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE">13. 原型，原型链</a></li>
<li><a href="#14-js-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">14. <strong>JS 中的常用的继承方式</strong></a></li>
<li><a href="#15-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">15. 内存泄漏</a></li>
<li><a href="#16-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">16. 垃圾回收机制</a></li>
<li><a href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">17. 深拷贝和浅拷贝</a></li>
<li><a href="#18-js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B">18. js是单线程</a></li>
<li><a href="#19-promise">19. promise</a></li>
<li><a href="#20-async%E5%92%8Cawait">20. async和await</a></li>
<li><a href="#21-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1">21. 宏任务和微任务</a></li>
<li><a href="#22-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">22. js执行机制(event loop 事件循环)</a></li>
<li><a href="#24-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">24. 防抖和节流</a></li>
<li><a href="#26-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9F%A5">26. 常用的数组方法（查）</a><ul>
<li><a href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">1. 冒泡排序</a></li>
<li><a href="#2-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC">2. 数组最大值</a></li>
<li><a href="#3-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. 数组去重</a></li>
<li><a href="#4-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84">4. 反转数组</a></li>
<li><a href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">5. 遍历数组</a><ul>
<li><a href="#1-for-of"><strong>1. for of</strong></a></li>
<li><a href="#2-foreach"><strong>2. forEach</strong></a></li>
<li><a href="#3-some">3. some</a></li>
<li><a href="#4-every">4. every</a></li>
<li><a href="#5-map">5. map</a></li>
<li><a href="#6-filter">6. filter</a></li>
<li><a href="#7-find">7. find()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#28-bom%E5%92%8Cdom%E7%9A%84%E5%8C%BA%E5%88%AB">28. <strong>bom和dom的区别</strong></a></li>
<li><a href="#29-js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F">29. JS性能优化的方式</a></li>
<li><a href="#30-defer-%E5%92%8C-async">30. defer 和 async</a></li>
<li><a href="#31-set%E5%92%8Cmap">31. set和map</a></li>
<li><a href="#32-for-of%E5%92%8Cfor-in">32. for of和for in</a></li>
<li><a href="#25-js%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5">25. js遍历数组的方法（查）</a></li>
<li><a href="#33-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">33. 数组去重</a></li>
<li><a href="#34-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">34. 数组排序</a></li>
<li><a href="#35-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA">35. <strong>什么是暂时性死区？</strong></a></li>
<li><a href="#36-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">36. 函数柯里化</a></li>
<li><a href="#37-null%E4%B8%8Eundefined%E7%9A%84%E5%8C%BA%E5%88%AB">37. null与undefined的区别</a></li>
<li><a href="#38-new-stringa%E5%92%8Cstringa">38. new String(‘a’)和String(‘a’)</a></li>
<li><a href="#39--%E5%92%8C--%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">39. || 和 &amp;&amp; 和！！操作符的返回值</a></li>
</ul>
</li>
<li><a href="#es6">ES6</a><ul>
<li><a href="#1-export-%E5%92%8C-export-default-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1. export 和 export default 有什么区别</a></li>
<li><a href="#2-varletconst%E5%8C%BA%E5%88%AB">2. var&#x2F;let&#x2F;const区别</a></li>
<li><a href="#3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">3. 箭头函数和普通函数的区别</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a><ul>
<li><a href="#0-axios%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85">0. Axios的二次封装</a></li>
<li><a href="#1-%E8%B7%A8%E5%9F%9F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%BC%95%E8%B5%B7%E7%9A%84">1. 跨域（同源策略引起的）</a></li>
<li><a href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">2. 三次握手</a></li>
<li><a href="#3-%E7%8A%B6%E6%80%81%E7%A0%81">3. 状态码</a></li>
<li><a href="#4-http">4. http</a></li>
<li><a href="#5-localstoragesessionstoragecookiesession">5. <strong>localStorage、SessionStorage、cookie、session</strong></a></li>
<li><a href="#6-token%E5%92%8Cjwt">6. token和JWT</a></li>
<li><a href="#7-get%E5%92%8Cpost">7. get和post</a></li>
<li><a href="#8-tcp%E5%92%8Cudp%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">8. tcp和udp网络协议</a></li>
<li><a href="#9-tcp%E9%87%8D%E4%BC%A0">9. tcp重传</a></li>
<li><a href="#10-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88----">10. <strong>从浏览器输入url后都经历了什么</strong>    ***</a></li>
<li><a href="#11-%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6">11. 回流和重绘，浏览器渲染机制</a></li>
<li><a href="#12-meta%E6%A0%87%E7%AD%BE">12. meta标签</a></li>
<li><a href="#13-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">13. 浏览器性能优化</a></li>
<li><a href="#14-%E7%99%BB%E9%99%86%E5%AE%9E%E7%8E%B0">14. 登陆实现</a></li>
<li><a href="#15-xss%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%92%8Ccsrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">15. xss(跨域脚本攻击)和csrf(跨站请求伪造)</a></li>
<li><a href="#16-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">16. 浏览器缓存</a></li>
<li><a href="#17-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">17. 进程和线程</a></li>
<li><a href="#18-url%E7%9A%84%E7%BB%93%E6%9E%84">18. url的结构</a></li>
<li><a href="#19-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84">19. 请求报文和响应报文的结构</a></li>
</ul>
</li>
<li><a href="#vue">VUE</a><ul>
<li><a href="#vue%E7%9A%84%E4%BC%98%E7%82%B9">VUE的优点</a></li>
<li><a href="#spa%E9%A1%B5%E9%9D%A2">SPA页面：</a></li>
<li><a href="#1-vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">1. vue双向绑定的原理</a></li>
<li><a href="#vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">Vue单向数据流</a></li>
<li><a href="#2-vue%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84">2. Vue监听数组</a></li>
<li><a href="#3-nexttick">3. nextTick</a></li>
<li><a href="#4-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4. Vue生命周期</a></li>
<li><a href="#5-computed-watchmethod%E7%9A%84%E5%8C%BA%E5%88%AB">5. computed 、watch、method的区别</a></li>
<li><a href="#6-vue%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F">6. Vue优化方式</a></li>
<li><a href="#7-vue-router">7. Vue-router</a><br>- <a href="#2-history%E6%A8%A1%E5%BC%8F">2. history模式</a><br>- <a href="#3-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94">3. 两种模式对比</a></li>
<li><a href="#8-diff%E7%AE%97%E6%B3%95">8. diff算法</a></li>
<li><a href="#9-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">9. 虚拟DOM的优缺点</a></li>
<li><a href="#10-vue%E7%9A%84keyindex">10. Vue的key（index）</a></li>
<li><a href="#11-vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1vuex">11. vue组件之间的通信（vuex）</a></li>
<li><a href="#12-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">12. <strong>Vue-router有哪几种钩子函数</strong></a></li>
<li><a href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0">13. <strong>为什么组件中 data 是个函数</strong></a></li>
<li><a href="#14-v-model">14. v-model</a></li>
<li><a href="#15-v-html%E5%92%8Cv-text">15. v-html和v-text</a></li>
<li><a href="#17-vue20%E5%92%8C30">17. vue2.0和3.0</a></li>
<li><a href="#18-vue%E7%9A%84set">18. <strong>vue的$set</strong></a></li>
<li><a href="#19-v-if%E5%92%8Cv-for">19. v-if和v-for</a></li>
<li><a href="#20-v-if-%E5%92%8C-v-show">20. <strong>v-if 和 v-show</strong></a></li>
<li><a href="#21-%E6%8F%92%E6%A7%BD">21. 插槽</a></li>
<li><a href="#22-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">22. 自定义事件</a></li>
<li><a href="#23-%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%97%B6%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8Edata%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8D%E5%8F%AF%E4%BB%A5%E5%90%8C%E5%90%8D%E5%90%97">23. 在使用计算属性时，函数名与data中的数据名可以同名吗</a></li>
<li><a href="#24-vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84">24. vue打包后静态资源路径</a></li>
<li><a href="#25-vue%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEimg">25. vue动态设置img</a></li>
<li><a href="#26-vue-%E4%B8%ADcreated%E5%92%8Cmounted%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE">26. vue 中created和mounted请求数据</a></li>
<li><a href="#27-%E5%A4%9A%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3">27. 多个后端接口</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93">项目总结</a><ul>
<li><a href="#%E7%99%BB%E9%99%86">登陆</a></li>
<li><a href="#1-%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">1. 登录验证</a></li>
<li><a href="#2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96">2. 项目的优化</a></li>
</ul>
</li>
</ul>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="1-html5有什么优化"><a href="#1-html5有什么优化" class="headerlink" title="1.  html5有什么优化"></a>1.  html5有什么优化</h3><ul>
<li>语义化标签的出现<ul>
<li>header</li>
<li>footer</li>
<li>section 等等等等</li>
</ul>
</li>
<li>还有 input 的优化<ul>
<li>可以给它的 type 设置成 number、tel、email 等等</li>
</ul>
</li>
<li>增加了表单的优化<ul>
<li>placeholder、required、min&#x2F;max、multiple 等等</li>
</ul>
</li>
<li>增加了 canvas</li>
<li>增加了 audio播放音频文件的标签</li>
</ul>
<h3 id="2-如何理解HTML语义化"><a href="#2-如何理解HTML语义化" class="headerlink" title="2. 如何理解HTML语义化"></a>2. 如何理解HTML语义化</h3><p>概念：合理正确的使用语义化的标签来创建页面结构（正确的标签做正确的事）</p>
<p>为了避免大篇幅的没有语义的标签来构建页面。</p>
<p>标签：header nav main article section aside footer</p>
<p>优点：1. 在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></p>
<pre><code>        2. `代码结构清晰`，易于阅读，
        2. `利于开发和维护` 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
        2. `有利于搜索引擎优化（SEO）`，搜索引擎爬虫会根据不同的标签来赋予不同的权重
</code></pre>
<h3 id="3-meta标签"><a href="#3-meta标签" class="headerlink" title="3. meta标签"></a>3. meta标签</h3><p>为浏览器提供 html 的元信息</p>
<p>规定 html 字符编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>设置移动端的视区窗口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta id=<span class="string">&quot;viewport&quot;</span> name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>设置 http 头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>图片403</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-src-和-href-的区别"><a href="#4-src-和-href-的区别" class="headerlink" title="4. src 和 href 的区别"></a>4. src 和 href 的区别</h3><ol>
<li>请求资源不同。<code>href</code>：超文本引用，用于建立文档与资源的联系，常用的有：link,a。<code>src</code>：将其所指向的资源下载并应用。</li>
<li>作用结果不同：<code>href</code>用于文档与资源之间建立联系。<code>src</code>请求到的资源替换当前内容。</li>
<li>浏览器的解析不同：<code>href</code>将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。<code>src</code>会暂停其他资源的处理，直到该资源加载、解析和执行完毕。</li>
</ol>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="0-css3有什么优化"><a href="#0-css3有什么优化" class="headerlink" title="0. css3有什么优化"></a>0. css3有什么优化</h3><ul>
<li>Border-radius、Border-shadow、border-image</li>
<li>还有动画效果 translate3d，<strong>css3的 translate3d 可以开启 gpu 加速</strong>，所以在使用动画的时候尽量要 css3的 translate3d，而不是 position：absolute+top+left</li>
<li>box-sizing</li>
</ul>
<h3 id="1-CSS选择器及优先级"><a href="#1-CSS选择器及优先级" class="headerlink" title="1. CSS选择器及优先级"></a>1. CSS选择器及优先级</h3><p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：<code>!important &gt; 行内样式&gt;嵌入样式和外链样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p>
<h3 id="2-position-属性的值有哪些及其区别"><a href="#2-position-属性的值有哪些及其区别" class="headerlink" title="2. position 属性的值有哪些及其区别"></a>2. position 属性的值有哪些及其区别</h3><p><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。<br> <strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。<br> <strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于浏览器窗口。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。<br> <strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。<br> <strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p>
<h3 id="3-box-sizing属性"><a href="#3-box-sizing属性" class="headerlink" title="3. box-sizing属性"></a>3. box-sizing属性</h3><p>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit<br> <strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】<br> <strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】<br> <strong>inherit</strong>：继承父元素的 box-sizing 值。</p>
<h3 id="4-CSS-盒子模型"><a href="#4-CSS-盒子模型" class="headerlink" title="4. CSS 盒子模型"></a>4. CSS 盒子模型</h3><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，<code>width 指 content 部分的宽度</code>。<br>在 IE 盒子模型中，<code>width 表示 content+padding+border 这三个部分的宽度</code>。</p>
<h3 id="5-BFC（块级格式上下文）和IFC-行级格式化上下"><a href="#5-BFC（块级格式上下文）和IFC-行级格式化上下" class="headerlink" title="5. BFC（块级格式上下文）和IFC(行级格式化上下)"></a>5. BFC（块级格式上下文）和IFC(行级格式化上下)</h3><p><code>BFC</code> 是 <code>Block Formatting Context </code>的缩写，即块级格式化上下文。<code>BFC</code>是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算</p>
<p>创建：</p>
<ul>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>
<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>
</ul>
<p>应用： 1.分属于不同的<code>BFC</code>时,可以防止<code>margin</code>重叠 2.清除内部浮动 3.自适应多栏布局</p>
<p>IFC：内联格式上下文</p>
<p>布局规则：1.内部的盒子会在水平方向，一个个地放置；<br>                        2.IFC的高度，由里面最高盒子的高度决定；<br>                        3.当一行不够放置的时候会自动切换到下一行</p>
<h3 id="6-水平垂直居中"><a href="#6-水平垂直居中" class="headerlink" title="6. 水平垂直居中"></a>6. 水平垂直居中</h3><ol>
<li><p>利用transform，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code> 来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  .<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code> 和 <code>margin-top</code> 以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  margin-<span class="attr">left</span>: -100px;</span><br><span class="line">  margin-<span class="attr">top</span>: -100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>flex</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  justify-<span class="attr">content</span>: center;</span><br><span class="line">  align-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h4><p>通过BFC和浮动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">content</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    margin-<span class="attr">right</span>: 10px;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    margin-<span class="attr">left</span>: 210px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过定位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">content</span>&#123;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span>&#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">left</span>: 210px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过flex：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    margin-right:10px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h4><p>普通三栏：通过定位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">    margin-left: 210px;</span><br><span class="line">    margin-right: 210px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过浮动实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">    background-<span class="attr">color</span>: gray;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    <span class="attr">float</span>: right;</span><br><span class="line">    background-<span class="attr">color</span>: gray;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">middle</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">    background-<span class="attr">color</span>: lightgray;</span><br><span class="line">    margin-<span class="attr">left</span>: 210px;</span><br><span class="line">    margin-<span class="attr">right</span>: 210px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>圣杯布局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">container</span> &#123;</span><br><span class="line">  padding-<span class="attr">left</span>: 220px;<span class="comment">//为左右栏腾出空间</span></span><br><span class="line">  padding-<span class="attr">right</span>: 220px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 400px;</span><br><span class="line">  <span class="attr">background</span>: red;</span><br><span class="line">  margin-<span class="attr">left</span>: -<span class="number">100</span>%;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">left</span>: -220px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">center</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">  <span class="attr">height</span>: 500px;</span><br><span class="line">  <span class="attr">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">  <span class="attr">float</span>: left;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 400px;</span><br><span class="line">  <span class="attr">background</span>: blue;</span><br><span class="line">  margin-<span class="attr">left</span>: -200px;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">right</span>: -220px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-用CSS实现三角符号"><a href="#7-用CSS实现三角符号" class="headerlink" title="7. 用CSS实现三角符号"></a>7. 用CSS实现三角符号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123; </span><br><span class="line">    <span class="attr">width</span>: 0px;   </span><br><span class="line">    <span class="attr">height</span>: 0px;  </span><br><span class="line">    border-<span class="attr">right</span>: 10px solid transparent;   </span><br><span class="line">    border-<span class="attr">top</span>: 30px solid #ff0;  </span><br><span class="line">    border-<span class="attr">left</span>: 10px solid transparent;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br></pre></td></tr></table></figure>



<h3 id="8-常见的布局类型（查）"><a href="#8-常见的布局类型（查）" class="headerlink" title="8. 常见的布局类型（查）"></a>8. 常见的布局类型（查）</h3><p>浮动，定位，flex,grid网格布局</p>
<p>浮动：</p>
<ul>
<li>优点：兼容性好</li>
<li>缺点：浮动会脱离标准文档流</li>
</ul>
<p>定位：</p>
<ul>
<li>优点：快捷</li>
<li>缺点：子元素也脱离了标准文档流，可用性差</li>
</ul>
<p>flex布局：弹性布局</p>
<ul>
<li>[<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]</a>:</li>
</ul>
<p>网格布局：</p>
<ul>
<li>[<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html]">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html]</a>:</li>
</ul>
<h3 id="9-浮动（查）"><a href="#9-浮动（查）" class="headerlink" title="9. 浮动（查）"></a>9. 浮动（查）</h3><p>设置浮动的图片，文字会环绕图片，设置浮动的块级元素，可以排列在一行，设置浮动的行内元素，可以设置宽高。</p>
<p>设置了浮动的元素会脱离文档流，如果父级盒子没有设置宽高，需要子盒子将她撑起来，则会造成高度塌陷。也会影响其他元素的排列。</p>
<ol>
<li><p>额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear:both）</p>
<p>新添加了一个标签，会造成不必要的渲染</p>
</li>
<li><p>父级添加overflow属性（overflow: hidden;）</p>
<p>写法方便简单，但是如果盒子中有定位元素超出了父级，则超出部分会隐藏。</p>
</li>
<li><p>使用after不会新增加标签，不回影响元素，是最流行的方法。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .<span class="property">clearfix</span>:：after&#123;<span class="comment">/*伪元素是行内元素 正常浏览器清除浮动方法*/</span></span><br><span class="line">        <span class="attr">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attr">display</span>: table;</span><br><span class="line">        <span class="attr">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">clearfix</span>&#123;</span><br><span class="line">        *<span class="attr">zoom</span>: <span class="number">1</span>;<span class="comment">/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fahter clearfix&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;big&quot;</span>&gt;</span>big<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;small&quot;</span>&gt;</span>small<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;div class=&quot;clear&quot;&gt;额外标签法&lt;/div&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-常见的行内元素和块级元素"><a href="#10-常见的行内元素和块级元素" class="headerlink" title="10. 常见的行内元素和块级元素"></a>10. 常见的行内元素和块级元素</h3><p>行内元素 inline</p>
<ul>
<li>span、input、img、textarea、label、select</li>
<li>不能设置宽高，多个元素共享一行，占满的时候会换行</li>
</ul>
<p> 块级元素block</p>
<ul>
<li>p、h1&#x2F;h2&#x2F;h3&#x2F;h4&#x2F;h5、div、ul、li、table</li>
<li>可以设置宽高，一个元素占满一整行</li>
</ul>
<p>inline-block</p>
<ul>
<li>可以设置宽高，多个元素共享一行，占满的时候会换行</li>
</ul>
<p>display</p>
<h3 id="11-px-em-rem-vw-vh-rpx等单位的特性"><a href="#11-px-em-rem-vw-vh-rpx等单位的特性" class="headerlink" title="11. px,em,rem,vw,vh,rpx等单位的特性"></a>11. px,em,rem,vw,vh,rpx等单位的特性</h3><p>px:像素</p>
<p>em:当前元素的字体大小</p>
<p>rem:根元素字体大小</p>
<p>vw:相对于视窗的宽度，视窗宽度是100vw</p>
<p>vh:相对于视窗的高度，视窗高度是100vh</p>
<p>rem单位翻译为像素值的时候是由html元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在html为font-size重写一个单位。</p>
<p>2.em单位转换为像素值的时候，取决于使用它们的元素的font-size的大小，但是有因为有继承关系，所以比较复杂。</p>
<h3 id="12-什么是DOM事件流？什么是事件委托-查"><a href="#12-什么是DOM事件流？什么是事件委托-查" class="headerlink" title="12. 什么是DOM事件流？什么是事件委托(查)"></a>12. <strong>什么是DOM事件流？什么是事件委托</strong>(查)</h3><ul>
<li>DOM事件流:事件发生时会在元素节点之间按照特定的顺序进行传播<ul>
<li>​	捕获阶段：最顶层节点开始，向下传播到目标元素接受的过程</li>
<li>​	目标阶段</li>
<li>​	冒泡阶段：目标元素接受然后逐级的向上传播</li>
</ul>
</li>
<li>在addeventListener()的第三个参数(useCapture)设为true，就会在捕获阶段运行，默认是false冒泡</li>
<li>事件委托:<ul>
<li>利用冒泡原理（子向父一层层穿透），把事件绑定到父元素中，以实现事件委托</li>
</ul>
</li>
</ul>
<h3 id="13-事件冒泡和事件捕捉有什么区别（查）"><a href="#13-事件冒泡和事件捕捉有什么区别（查）" class="headerlink" title="13. 事件冒泡和事件捕捉有什么区别（查）"></a>13. 事件冒泡和事件捕捉有什么区别（查）</h3><ul>
<li>事件冒泡<ul>
<li>在<code>addEventListener</code>中的第三属性设置为false（默认）</li>
<li>从下至上（儿子至祖宗）执行</li>
<li>阻止事件冒泡：<ul>
<li>e.stopPropagation</li>
</ul>
</li>
</ul>
</li>
<li>事件捕捉<ul>
<li>在<code>addEventListener</code>中的第三属性设置为true</li>
<li>从上至下（祖宗到儿子）执行</li>
</ul>
</li>
</ul>
<h3 id="14-link和-import"><a href="#14-link和-import" class="headerlink" title="14. link和@import"></a>14. link和@import</h3><p>1、从属关系：link是html的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；而@import是css的语法，只有导入样式表的作用。</p>
<p>2、加载顺序：页面被加载时，link会和html同时被加载而；@import引入的 CSS 将在页面加载完毕后被加载。</p>
<p>3、兼容性：@import是 CSS2.1 才有的语法，所以只能在 IE5以上 才能识别；而link是 HTML 标签，所以不存在兼容性问题。</p>
<p>4、DOM：javascript只能控制dom去改变link标签引入的样式，而@import的样式不是dom可以控制的。</p>
<p>5、link方式的样式权重高于@import的权重</p>
<h3 id="15-响应式布局"><a href="#15-响应式布局" class="headerlink" title="15. 响应式布局"></a>15. 响应式布局</h3><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。。</p>
<ol>
<li>媒体查询：可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</li>
<li>rem布局：默认情况下我们html标签的<code>font-size</code>为16px,我们利用媒体查询，设置在不同设备下的字体大小。</li>
<li>如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。</li>
</ol>
<h3 id="16-元素不可见"><a href="#16-元素不可见" class="headerlink" title="16. 元素不可见"></a>16. 元素不可见</h3><p><strong>display:none</strong></p>
<ul>
<li>该元素和他的子元素不会被渲染</li>
<li>会让元素从DOM消失，渲染的时候不占据任何空间</li>
</ul>
<p><strong>visibility:hidden</strong></p>
<ul>
<li>隐藏元素而不更改文档的布局</li>
<li>不会让元素从DOM消失，渲染的时候任然占据原来的空间</li>
</ul>
<p><strong>opacity:0</strong></p>
<ul>
<li>元素完全透明</li>
<li>不会让元素从DOM消失，渲染的时候任然占据原来的空间</li>
</ul>
<h3 id="17-css动画属性"><a href="#17-css动画属性" class="headerlink" title="17. css动画属性"></a>17. css动画属性</h3><ul>
<li><h4 id="transform-translate-参数1，参数2-———位移属性"><a href="#transform-translate-参数1，参数2-———位移属性" class="headerlink" title="transform:translate(参数1，参数2)———位移属性"></a>transform:translate(参数1，参数2)———位移属性</h4></li>
<li><h4 id="transform-scale-———-2D缩放"><a href="#transform-scale-———-2D缩放" class="headerlink" title="transform:scale()———-2D缩放"></a>transform:<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=scale&spm=1001.2101.3001.7020">scale</a>()———-2D缩放</h4></li>
<li><h4 id="transform-rotate-———2D旋转"><a href="#transform-rotate-———2D旋转" class="headerlink" title="transform:rotate()———2D旋转"></a>transform:rotate()———2D旋转</h4></li>
<li><p>@keyframes 关键帧名称{<br>  from{初始状态属性}<br>  to{结束状态属性}}</p>
</li>
</ul>
<h4 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h4><ul>
<li><h4 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h4></li>
</ul>
<p>所应用的动画名称（关键帧名称），必须配合@keyframes使用。</p>
<ul>
<li><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4></li>
</ul>
<p>动画持续的时间，例：animation-duration:3s; 即为动画的持续时间为3s。</p>
<ul>
<li><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4></li>
</ul>
<p> 动画的运动状态：<br>linear：匀速。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)<br>ease：平滑。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)<br>ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)<br>ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)<br>ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) </p>
<ul>
<li><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4></li>
</ul>
<p> 动画的循坏次数：<br>infinite： 无限循环<br>number: 循环的次数 </p>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h3 id="0-Object常用的API"><a href="#0-Object常用的API" class="headerlink" title="0. Object常用的API"></a>0. Object常用的API</h3><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">isHuman</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">printIntroduction</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="variable language_">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br></pre></td></tr></table></figure>

<p>Object.is()方法判断两个值是否为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">同一个值</a>。</p>
<p> Object.hasOwnProperty()方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p>
<p><code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<p><code>**Object.values()**</code>方法返回一个给定对象自身的所有可枚举value的数组</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><p> <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code>  、 <code>Symbol</code> 、 <code>BigInt</code></p>
<ul>
<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>
<li>BigInt 可以表示任意大小的整数。处理转换当中的精度缺失，它提供了一种方法来表示大于 <code>2^53 - 1</code> 的整数，在最后加n定义</li>
</ul>
<h3 id="2-数据类型检测"><a href="#2-数据类型检测" class="headerlink" title="2. 数据类型检测"></a>2. 数据类型检测</h3><table>
<thead>
<tr>
<th>不同类型</th>
<th><code>typeof</code></th>
<th><code>instanceof</code></th>
<th><code>Object.prototype.toString.call()</code></th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>快速区分基本类型</td>
<td>能够区分Array、Object和Function，原理：查找目标对象的原型链</td>
<td>精准判断数据类型</td>
</tr>
<tr>
<td>缺点</td>
<td>不能将Object、Array和Null区分，都返回object</td>
<td>Number，Boolean，String基本数据类型不能判断</td>
<td>写法繁琐不容易记，推荐进行封装后使用</td>
</tr>
</tbody></table>
<p>constructor:返回创建实例对象的构造函数的引用</p>
<p>如何判断变量是否为数组？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr); <span class="comment">// true</span></span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断一个数是整数：</p>
<p>Number.isInteger，取余</p>
<p>类数组转换为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>array &#x3D; Array.from(arr);</p>
<h3 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h3><p><strong>强制转换</strong></p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>String()和toString()</li>
<li>Boolean()</li>
</ul>
<p><strong>自动转换</strong></p>
<ul>
<li>比较运算</li>
<li>算术运算</li>
</ul>
<h3 id="4-作用域和作用域链"><a href="#4-作用域和作用域链" class="headerlink" title="4. 作用域和作用域链"></a>4. 作用域和作用域链</h3><p>作用域：规定变量和函数的可适用范围称作用域，分为全局作用域和局部作用域</p>
<ul>
<li>全局作用域为程序的最外层作用域，一直存在</li>
<li>函数作用域只有函数被定义时才会创建，包含在父级函数作用域 &#x2F; 全局作用域内。</li>
<li>由于作用域的限制，每段独立的执行代码块只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量。</li>
</ul>
<p>作用域链：当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找…一直找到全局作用域。我们把这种作用域的嵌套机制，称为作用域链。</p>
<h3 id="5-什么是闭包"><a href="#5-什么是闭包" class="headerlink" title="5. 什么是闭包"></a>5. 什么是闭包</h3><p>闭包是指嵌套在一个函数内部中的函数。当一个嵌套的子函数引用了外部复函数的变量时，就产生了闭包。</p>
<p>原理：当前作用域可以访问上级作用域中的变量</p>
<p>作用：</p>
<p>（1）保护：<br> （2）保存：当前上下文的某些内容被上下文以外的内容占用，当前上下文不被释放，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来</p>
<p>优点和缺点：延长局部变量的生命周期，但会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<p><strong>应用：</strong>setTimeout，柯里化(是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。)，模仿块级作用域，函数防抖和节流</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">create</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决办法：在退出函数之前，将不使用的局部变量全部删除。</p>
<h3 id="6-this的指向"><a href="#6-this的指向" class="headerlink" title="6. this的指向"></a>6. this的指向</h3><ul>
<li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的<code>执行环境</code>动态绑定的，而非函数被声明时的环境；</li>
<li>this 在严格模式下 指向 undefined</li>
<li>this存在的环境有三种，全局执行上下文和函数执行上下文，eval。</li>
</ul>
<p><strong>1、作为对象的方法调用</strong></p>
<p>当函数作为对象的方法被调用时，<code>this指向该对象</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;yuguang&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// true yuguang</span></span><br></pre></td></tr></table></figure>

<p><strong>2、作为普通函数调用</strong></p>
<p>this总是指向全局对象（在浏览器中，通常是Window对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;yuguang&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNew = obj.<span class="property">getName</span>;</span><br><span class="line"><span class="title function_">getNew</span>(); <span class="comment">// 老王</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、构造器调用</strong></p>
<p>当new运算符调用函数时，总是返回一个对象，this通常也指向这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;yuguang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">obj.<span class="property">name</span>; <span class="comment">// yuguang</span></span><br></pre></td></tr></table></figure>

<p>但是，如果显式的返回了一个object对象，那么此次运算结果最终会返回这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myClass:&#x27;</span>, myClass); <span class="comment">// &#123; name: 2&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4、call或apply调用</strong></p>
<p>跟普通的函数调用相比，用call和apply可以动态的改变函数的this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params">num = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">call</span>(obj2, <span class="number">2</span>)); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">apply</span>(obj2, [<span class="number">2</span>])); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5.箭头函数</strong></p>
<p>箭头函数不会创建自己的this，它只会从自己的父类执行上下文继承this。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">val</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getVal</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getVal</span>(); <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-new-实现"><a href="#7-new-实现" class="headerlink" title="7. new 实现"></a>7. new 实现</h3><ol>
<li><p>首先创一个新的空对象。</p>
</li>
<li><p>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</p>
</li>
<li><p>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</p>
</li>
<li><p>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</p>
</li>
<li><pre><code class="javascript">function createPerson(name,age)&#123;
    // 1.实例化Object对象
    const o=new Object()
    // 2.改变构造函数的this指向
    Person.call(o,name,age)
    // 3.原型链继承
    o.__proto__=Person.prototype
    // 4.返回这个对象
    return o
  &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   创建一个空对象</span><br><span class="line">   </span><br><span class="line">   `object.create(null)`</span><br><span class="line"></span><br><span class="line">### 8. **0.1+0.2&gt;0.3** </span><br><span class="line"></span><br><span class="line">因为在JS底层中，每个变量是以二进制表示，固定长度为64位，其中第1位是符号位，再往后11位是指数为，最后52表示的是尾数位，而0.1和0.2转为二进制的时候是无限循环小数，所以JS就会进行截取，截取以后0.1和0.2就不是他们本身了，要比原来大那么一丢丢，所以0.1+0.2就&gt;0.3了</span><br><span class="line"></span><br><span class="line">解决：先给他们**放大倍数**，随后在**除以相应倍数**</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const a = 0.1;</span><br><span class="line">const b = 0.2;</span><br><span class="line"></span><br><span class="line">console.log(a + b === 0.3)   // false</span><br><span class="line">console.log((a * 1000 + b * 1000) / 1000 === 0.3)  // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="9-和-的区别"><a href="#9-和-的区别" class="headerlink" title="9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别"></a>9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</h3><p>&#x3D;&#x3D;&#x3D;是严格意义上的相等，会比较两边的数据类型和值大小</p>
<p>&#x3D;&#x3D;是非严格意义上的相等</p>
<p>Null &#x3D;&#x3D; Undefined -&gt;true<br>String &#x3D;&#x3D; Number -&gt;先将String转为Number，在比较大小<br>Boolean &#x3D;&#x3D; Number -&gt;现将Boolean转为Number，在进行比较<br>Object &#x3D;&#x3D; String，Number，Symbol -&gt; Object 转化为原始类型</p>
<h3 id="10-NaN-NaN返回什么"><a href="#10-NaN-NaN返回什么" class="headerlink" title="10. NaN === NaN返回什么"></a>10. <strong><code>NaN === NaN</code>返回什么</strong></h3><p>返回 <code>false</code>，<code>NaN</code>永远不等于<code>NaN</code>，判断是否为<code>NaN</code>用一个函数 <code>isNaN</code>来判断；</p>
<p><code>isNaN</code>传入的如果是其他数据类型，那么现将它使用<code>Number()</code>转为数字类型在进行判断</p>
<h3 id="11-手写call、apply、bind（查）"><a href="#11-手写call、apply、bind（查）" class="headerlink" title="11. 手写call、apply、bind（查）"></a>11. <strong>手写call、apply、bind</strong>（查）</h3><p>三者都是改变this的指向的方法，</p>
<p>判断是否是函数，call和apply都会调用函数，改变函数内部this的指向。</p>
<p>call和apply传递的参数不一样</p>
<p>call:</p>
<ul>
<li>如果不传参数，或者第一个参数是<code>null</code>或<code>nudefined</code>，<code>this</code>都指向<code>window</code></li>
<li>第一个参数是谁，this就指向谁，包括null和undefined，如果不传参数this就是undefined</li>
</ul>
<p>apply:</p>
<ul>
<li>apply把需要传递给fn的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给fn一个个的传递</li>
</ul>
<p>bind:改变函数内部的this指向，函数不会被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 先判断调用myCall是不是一个函数</span></span><br><span class="line">  <span class="comment">// 这里的this就是调用myCall的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不传参数默认为window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存this</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存参数</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>).<span class="title function_">slice</span>(<span class="number">1</span>)   <span class="comment">//Array.from 把伪数组对象转为数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断this是不是函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 默认是window</span></span><br><span class="line">      context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存this</span></span><br><span class="line">      context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否传参</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>)&#123;</span><br><span class="line">  <span class="comment">// 判断是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Not a Function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存调用bind的函数</span></span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span> </span><br><span class="line">  <span class="comment">// 保存参数</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span> () &#123;</span><br><span class="line">    <span class="comment">// 判断是不是new出来的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="comment">// 如果是new出来的</span></span><br><span class="line">      <span class="comment">// 返回一个空对象，且使创建出来的实例的__proto__指向_this的prototype，且完成函数柯里化</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args,...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 如果不是new出来的改变this指向，且完成函数柯里化</span></span><br><span class="line">      <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context,args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="12-执行栈和执行上下文"><a href="#12-执行栈和执行上下文" class="headerlink" title="12. 执行栈和执行上下文"></a>12. 执行栈和执行上下文</h3><p>执行栈：</p>
<ul>
<li>首先栈特点：先进后出</li>
<li>每次函数调用时，就会创建出它的执行上下文，然后进行压栈，当函数执行完成时，它的执行上下文就会被销毁，进行弹栈。</li>
<li>栈底永远是全局环境的执行上下文，栈顶永远是正在执行函数的执行上下文</li>
<li>只有浏览器关闭的时候全局执行上下文才会弹出</li>
</ul>
<p>执行上下文：</p>
<ul>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。</li>
<li>函数执行上下文：每次函数调用时，都会新创建一个函数执行上下文</li>
</ul>
<h3 id="13-原型，原型链"><a href="#13-原型，原型链" class="headerlink" title="13. 原型，原型链"></a>13. 原型，原型链</h3><p>每个实例对象上都有一个 <code>__proto__ </code>隐式原型属性,每个构造函数都有一个<code>prototype</code>显示原型属性，两者都指向了构造函数的原型对象上。原型对象上的方法和属性能够被实例对象所共享。而原型对象上也是一个对象，他也有自己的原型。就这样一层一层的往上，直到Object的原型对象上的__proto__为null，就这样一层一层的链条形成了原型链。这也就是为什么每个对象都能够使用Object.prototype.tostring的方法</p>
<h3 id="14-JS-中的常用的继承方式"><a href="#14-JS-中的常用的继承方式" class="headerlink" title="14. JS 中的常用的继承方式"></a>14. <strong>JS 中的常用的继承方式</strong></h3><p>原型继承、构造函数继承、组合继承，寄生组合继承、ES6的extend</p>
<p>原型继承：会共享引用属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// ----------------------方法一：原型继承</span></span><br><span class="line">   <span class="comment">// 原型继承</span></span><br><span class="line">   <span class="comment">// 把父类的实例作为子类的原型</span></span><br><span class="line">   <span class="comment">// 缺点：子类的实例共享了父类构造函数的引用属性 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;unknow&#x27;</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">score</span> = <span class="number">80</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;lucy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>);  <span class="comment">//lucy  --子类覆盖父类的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">age</span>);   <span class="comment">// 0    --父类的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">score</span>);  <span class="comment">// 80   --子类自己的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造函数继承：会独享所有属性，包括引用属性（重点是函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">hobbies</span> = [<span class="string">&#x27;music&#x27;</span>,<span class="string">&#x27;reading&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">stu1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;basketball&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">hobbies</span>);  <span class="comment">// [&quot;music&quot;, &quot;reading&quot;, &quot;basketball&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">hobbies</span>);  <span class="comment">//  [&quot;music&quot;, &quot;reading&quot;]</span></span><br></pre></td></tr></table></figure>

<p>组合继承：利用原型链继承要共享的属性，利用构造函数继承要独享的属性，实现相对完美的继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法二：组合继承</span></span><br><span class="line"><span class="comment">// 在子函数中运行父函数，但是要利用call把this改变一下，</span></span><br><span class="line"><span class="comment">// 再在子函数的prototype里面new Father() ,使Father的原型中的方法也得到继承，最后改变Son的原型中的constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点：调用了两次父类的构造函数，造成了不必要的消耗，父类方法可以复用</span></span><br><span class="line"><span class="comment">// 优点可传参，不共享父类引用属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>]</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ming&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>寄生组合继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法三：寄生组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ming&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>extend：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------方法四：ES6的extend（寄生组合继承的语法糖）</span></span><br><span class="line"><span class="comment">//     子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话</span></span><br><span class="line"><span class="comment">// 必须是 super 。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123; <span class="comment">// Son.prototype.__proto__ = Father.prototype</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">200</span>)  <span class="comment">// super(200) =&gt; Father.call(this,200)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-内存泄漏"><a href="#15-内存泄漏" class="headerlink" title="15. 内存泄漏"></a>15. 内存泄漏</h3><p>概念：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏（全局变量、闭包、DOM 元素的引用、定时器）</p>
<p>原因：内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法使用，积少成多，系统会越来越卡以至于崩溃</p>
<p>解决：避免使用全局变量，手动删除定时器和DOM,removeEventListener移除事件监听。</p>
<h3 id="16-垃圾回收机制："><a href="#16-垃圾回收机制：" class="headerlink" title="16. 垃圾回收机制："></a>16. 垃圾回收机制：</h3><ul>
<li>标记清除法</li>
</ul>
<p>垃圾回收机制获取根节点并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除</p>
<ul>
<li>引用计数法</li>
</ul>
<p>当声明一个变量并赋值时，值+1，当该值被取代时-1，为0时进行删除。</p>
<h3 id="17-深拷贝和浅拷贝"><a href="#17-深拷贝和浅拷贝" class="headerlink" title="17. 深拷贝和浅拷贝"></a>17. 深拷贝和浅拷贝</h3><p>浅拷贝：创建了一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，则拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<ol>
<li><strong>Object.assign() 方法：</strong> 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li><strong>Array.prototype.slice()：</strong>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>
<li><strong>拓展运算符<code>...</code></strong></li>
</ol>
<p>深拷贝：拷贝所有的属性，并在计算机中开辟出了一块新的内存，拷贝前后两个对象互不影响。</p>
<p>js实用工具库，提供了许多API</p>
<ul>
<li>Lodash中的_.cloneDeep()，_.merge(a,b)(合并)，_.reject()（根据条件去除某个元素）</li>
<li>手写循环递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = <span class="title function_">clone</span>(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON.parse(JSON.stringify())</li>
</ul>
<p>缺点：NaN &#x3D;&#x3D;&#x3D;&gt; null</p>
<p>​			undefined 函数 &#x3D;&#x3D;&#x3D;&gt; 丢失</p>
<p>​			时间戳 &#x3D;&#x3D;&#x3D;&gt; 字符串时间</p>
<p>​			错误信息 &#x3D;&#x3D;&#x3D;&gt; 空对象</p>
<p>​			循环引用对象 &#x3D;&#x3D;&#x3D;》 报错</p>
<p>​			obj中有属性是new出来的，则会丢弃对应的constructor 初始化构造器</p>
<h3 id="18-js是单线程"><a href="#18-js是单线程" class="headerlink" title="18. js是单线程"></a>18. js是单线程</h3><p>因为JS里面有可视的Dom，如果是多线程的话，这个线程正在删除DOM节点，另一个线程正在编辑Dom节点，导致浏览器不知道该听谁的。</p>
<h3 id="19-promise"><a href="#19-promise" class="headerlink" title="19. promise"></a>19. promise</h3><p><code>promise</code>是异步编程的解决方案，简单来说就是一个容器，里面保存着一个异步操作的结果，从语法上说，<code>promise</code>是一个对象，可以改变对象获取异步操作的消息。promise共有三个状态</p>
<p>pending（执行中）、success（成功）、rejected（失败）</p>
<p>状态只能由 Pending –&gt; Fulfilled 或者 Pending –&gt; Rejected，且一但发生改变便不可二次修改</p>
<p>作用：他可以解决回调地狱的问题，也就是异步深层嵌套的问题。</p>
<p>基本使用：我们可以new一个promise  <code>promise</code>的构造函数接受一个函数，并且传入两个参数：<code>resolve</code>和<code>reject</code>分别表示异步操作执行成功的回调和失败的回调。<code>promise</code>实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p>
<p>.catch()：获取异常信息</p>
<p>.all()：Promise.all()创建的Promise会在这一组Promise全部解决后在解决。也就是说会等待所有的promise程序都返回结果之后执行后续的程序。返回一个新的Promise。应用：当需要加载的资源较多时。</p>
<ul>
<li>如果所有都成功，则合成Promise的返回值就是所有子Promise的返回值数组。</li>
<li>如果有一个失败，那么第一个失败的会把自己的理由作为合成Promise的失败理由</li>
</ul>
<p>.race()：得到的却是数组中跑的最快的那个，当最快的一跑完就立马结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">		//做一些异步操作</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			var flag = false</span><br><span class="line">			if(flag) &#123;</span><br><span class="line">			resolve(&#x27;hello&#x27;)</span><br><span class="line">			&#125;	else &#123;</span><br><span class="line">				reject(&#x27;出错了&#x27;)</span><br><span class="line">					&#125;</span><br><span class="line">		&#125;, 2000);</span><br><span class="line">	&#125;);</span><br><span class="line">	p.then(function(data) &#123;</span><br><span class="line">	console.log(&#x27;成功回调&#x27;,data)</span><br><span class="line">	&#125;,function(info) &#123;</span><br><span class="line">	console.log(&#x27;失败了&#x27;,info))</span><br></pre></td></tr></table></figure>

<p>通过promise获取网络图片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>手写promise加载图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> url1=<span class="string">&#x27;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3719520752,2657134858&amp;fm=26&amp;gp=0.jpg&#x27;</span><span class="comment">//网上随便找一个图片的地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> url2=<span class="string">&#x27;https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3461776228,1302027451&amp;fm=26&amp;gp=0.jpg&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">function</span> <span class="title function_">loadImage</span>(<span class="params">src</span>)&#123;<span class="comment">//定义一个异步加载图片的函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="comment">//new一个promise对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="keyword">const</span> img =<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)<span class="comment">//创建一个img节点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">src</span>=src<span class="comment">//把我们的图片地址给我们新建的节点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">onload</span>=<span class="function">()=&gt;</span>&#123;<span class="comment">//通过监听节点成功建立（当然图片也传进去）调用resolve</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				<span class="title function_">resolve</span>(img)<span class="comment">//返回整个节点,可以用.then捕捉</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			img.<span class="property">onerror</span>=<span class="function">()=&gt;</span>&#123;<span class="comment">//监听错误，可以用.catch捕捉</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				<span class="title function_">reject</span>(<span class="string">`图片加载失败，地址为<span class="subst">$&#123;src&#125;</span>`</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">return</span> p<span class="comment">//记得把整个promise对象返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="title function_">loadImage</span>(url1)<span class="comment">//调用异步函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="20-async和await"><a href="#20-async和await" class="headerlink" title="20. async和await"></a>20. async和await</h3><p>作用：async用于申明一个function是异步的，而await用于等待一个异步方法执行完成，他可以很好的替代promise中的then。</p>
<p>async函数返回一个promise对象，当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，在接着执行函数体内后面的语句</p>
<h3 id="21-宏任务和微任务"><a href="#21-宏任务和微任务" class="headerlink" title="21. 宏任务和微任务"></a>21. 宏任务和微任务</h3><ul>
<li>宏任务：script,setTimeOut<code>、</code>setInterval,DOM事件</li>
<li>微任务：promise.then<code>,</code>process.nextTick<code>、</code>MutationObserver</li>
<li>微任务比宏任务先执行</li>
<li>promise的resolve是同步的，async遇到await之前是同步的，在执行await后面的代码，返回promise,await下面的代码放入微任务并退出。</li>
</ul>
<h3 id="22-js执行机制-event-loop-事件循环"><a href="#22-js执行机制-event-loop-事件循环" class="headerlink" title="22. js执行机制(event loop 事件循环)"></a>22. js执行机制(event loop 事件循环)</h3><p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。</p>
<p>1）所有的同步任务都在主线程上执行，行成一个执行栈。</p>
<p>2）除了主线程之外，还存在一个任务列队event table，只要异步任务有了运行结果，Event Table会将这个函数移入Event Queue。</p>
<p>3）但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行宏任务中的微任务，将微任务放入eventqueue，但是两个queue不同。</p>
<p>4）主线程执行完毕后，会去微任务queue中读取，进入主线程执行，再从宏任务的queue读取。</p>
<p>5）重复上面三步。</p>
<h3 id="24-防抖和节流"><a href="#24-防抖和节流" class="headerlink" title="24. 防抖和节流"></a>24. 防抖和节流</h3><p>防抖：n秒后在执行该事件，若在n秒内被重复触发，则重新计时（频繁操作点赞和取消点赞，搜索联想，）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce2</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timer</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123; <span class="title function_">fn</span>(args) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效（鼠标不断点击触发）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle2</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> timer</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">       <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">       <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">         timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           timer = <span class="literal">null</span></span><br><span class="line">           fn.<span class="title function_">apply</span>(_this, <span class="variable language_">arguments</span>)</span><br><span class="line">         &#125;, wait);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</p>
<h3 id="26-常用的数组方法（查）"><a href="#26-常用的数组方法（查）" class="headerlink" title="26. 常用的数组方法（查）"></a>26. 常用的数组方法（查）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;李白&quot;</span>, <span class="number">123</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>]</span><br><span class="line">        <span class="comment">// 在数组末尾增加 push()</span></span><br><span class="line">        arr.<span class="title function_">push</span>(<span class="string">&quot;剑仙&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 在数组末尾删除 pop()</span></span><br><span class="line">        arr.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 在数组开头删除 shift()</span></span><br><span class="line">        arr.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 删除 splice()</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        <span class="comment">// 修改 splice()</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;诗圣&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组转化为字符串 join() 产生一个新数组，不会改变原数组 以xx隔开</span></span><br><span class="line">        <span class="keyword">var</span> arr1 = arr.<span class="title function_">join</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br><span class="line">        <span class="comment">// 合并两个数组 concat() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr3 = arr.<span class="title function_">concat</span>(arr1)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);</span><br><span class="line">        <span class="comment">// 数组的截取 slice() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr4 = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr4);</span><br><span class="line">        <span class="comment">// 数组的翻转 reverse() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr5 = arr.<span class="title function_">reverse</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr5);</span><br><span class="line">        <span class="comment">// 数组排序 sort() 产生一个新数组，不会改变原数组</span></span><br><span class="line">        <span class="keyword">var</span> arr6 = arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr6);</span><br></pre></td></tr></table></figure>

<h4 id="1-数组排序"><a href="#1-数组排序" class="headerlink" title="1. 数组排序"></a>1. 数组排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= arr.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h4 id="2-数组最大值"><a href="#2-数组最大值" class="headerlink" title="2. 数组最大值"></a>2. 数组最大值</h4><h5 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">343</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">65</span>, <span class="number">234</span>]</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                max = a[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(max);</span><br></pre></td></tr></table></figure>

<h4 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3. 数组去重"></a>3. 数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">54</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                    arr.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">                    j--  <span class="comment">// 因为每次删除都会改变数组的长度，所以删了之后要是下标-1,之后再+1回到原来下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h4 id="4-反转数组"><a href="#4-反转数组" class="headerlink" title="4. 反转数组"></a>4. 反转数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;hotpink&#x27;</span>];</span><br><span class="line">        <span class="keyword">var</span> newArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            newArr[newArr.<span class="property">length</span>] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br></pre></td></tr></table></figure>

<h4 id="5-遍历数组"><a href="#5-遍历数组" class="headerlink" title="5. 遍历数组"></a>5. 遍历数组</h4><h5 id="1-for-of"><a href="#1-for-of" class="headerlink" title="1. for of"></a><strong>1. for of</strong></h5><ul>
<li>不同于forEach的是，for of 循环可以随时退出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;hotpink&#x27;</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">//red green blue pink purplr hotpink</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-forEach"><a href="#2-forEach" class="headerlink" title="2. forEach"></a><strong>2. forEach</strong></h5><ul>
<li>可以通过return跳出本次循环，执行下一次循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 4 5 6</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-some"><a href="#3-some" class="headerlink" title="3. some"></a>3. some</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>检测数组里的每一个值是否满足条件，如果有一个满足就返回true，否则返回false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">const</span> result = arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3</span></span><br><span class="line">      <span class="keyword">return</span> item === <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="4-every"><a href="#4-every" class="headerlink" title="4. every"></a>4. every</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>检测数组里的每一个值是否满足条件，如果有一个不满足就返回false，否则返回true</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">const</span> result = arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 </span></span><br><span class="line">      <span class="keyword">return</span> item === <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="5-map"><a href="#5-map" class="headerlink" title="5. map"></a>5. map</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>按照原始数组元素顺序依次处理，返回一个新数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">   <span class="keyword">const</span> result = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3 4 5 6 </span></span><br><span class="line">     <span class="keyword">return</span> item * item</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// [1 4 9 16 25 36]</span></span><br></pre></td></tr></table></figure>

<h5 id="6-filter"><a href="#6-filter" class="headerlink" title="6. filter"></a>6. filter</h5><ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
<li>对数组进行渲染，返回符合条件的数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">   <span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">     <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>

<h5 id="7-find"><a href="#7-find" class="headerlink" title="7. find()"></a>7. find()</h5><ul>
<li><p>不会对空数组进行检测</p>
</li>
<li><p>不会改变原数组</p>
</li>
<li><p>找到符合条件的第一项，没有找到返回undefined</p>
</li>
<li><pre><code class="js">var arr = [1, 2, 3, 4, 5, 6]
    const result = arr.find((item) =&gt; &#123;
      console.log(item) // 1 2 3 4 5 6
      return item &gt; 3
    &#125;)
    console.log(result) // 4
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 27. 常用的字符串方法（查）</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"> 		// 字符串的长度                length</span><br><span class="line">        console.log(str1.length)</span><br><span class="line">        // 通过下标获取某个字符       str.charAt()</span><br><span class="line">        let str5 = &#x27;我是一个字符串&#x27;</span><br><span class="line">        console.log(str5.charAt(3))</span><br><span class="line">        // 截取字符串 str.slice()</span><br><span class="line">        console.log(str5.slice(2, 4))</span><br><span class="line"></span><br><span class="line">        // 返回字符串第一次出现的位置  没有出现过返回-1 str.indexOf()</span><br><span class="line">        console.log(str5.indexOf(&#x27;123&#x27;))</span><br><span class="line">        console.log(str5.search(&#x27;个&#x27;))</span><br><span class="line">        // indexOf和search的区别    indexOf只能匹配字符串</span><br><span class="line">        // search可以匹配 正则和字符串</span><br><span class="line">        </span><br><span class="line">        // 替换字符串                  str.replace()</span><br><span class="line">        let str6 = &#x27;sldjfsljflskjfdslfjdsl&#x27;</span><br><span class="line">        let str7 = str6.replace(&#x27;s&#x27;, &#x27;我的&#x27;)</span><br><span class="line">        console.log(str7, str6)</span><br><span class="line"></span><br><span class="line">        // 分割字符串转化为数组          str.split()</span><br><span class="line">        console.log(str6.split(&#x27;s&#x27;))</span><br><span class="line"></span><br><span class="line">        // 表单里面比较重要的的      str.trim()</span><br><span class="line">        let str8 = &#x27; 我的字符 &#x27;</span><br><span class="line">        console.log(str8.length)</span><br><span class="line">        console.log(str8.trim().length)</span><br><span class="line"></span><br><span class="line">        // 判断字符串是否有某个字符  str.includes()</span><br><span class="line">        console.log(str8.includes(&#x27;我&#x27;))</span><br><span class="line">        // 多一嘴 数组也是一样的方法</span><br><span class="line">        let arr = [1, 2, 3, 45, 3, 1, &#x27;123&#x27;, 12]</span><br><span class="line">        console.log(arr.includes(123))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="28-bom和dom的区别"><a href="#28-bom和dom的区别" class="headerlink" title="28. bom和dom的区别"></a>28. bom和dom的区别</h3><ul>
<li><p>bom就是window，包含windows（窗口）、navigator（浏览器）、screen（浏览器屏幕）、history（访问历史）、location（地址）等，浏览器相关的东西。bom是包含dom的。</p>
</li>
<li><p>dom是document， html相关的都在里面</p>
</li>
</ul>
<h3 id="29-JS性能优化的方式"><a href="#29-JS性能优化的方式" class="headerlink" title="29. JS性能优化的方式"></a>29. JS性能优化的方式</h3><ul>
<li>垃圾回收</li>
<li>防抖节流</li>
<li>分批加载（setInterval,加载10000个节点）</li>
<li>事件委托</li>
<li>requestAnimationFrame的使用</li>
<li>script标签中的defer和async</li>
<li>CDN（CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求）</li>
</ul>
<h3 id="30-defer-和-async"><a href="#30-defer-和-async" class="headerlink" title="30. defer 和 async"></a>30. defer 和 async</h3><ul>
<li><p>浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
</li>
<li><p>然后是 defer和 async；他们两个是异步加载 js 代码的。</p>
</li>
<li><p>defer，async</p>
<ul>
<li><p>渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<strong>defer是“渲染完再执行”，async是“下载完就执行”</strong>。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="31-set和map"><a href="#31-set和map" class="headerlink" title="31. set和map"></a>31. set和map</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。通过 <em><strong>*add方法*</strong></em> 向 Set 结构加入成员，也可以利用set进行数组去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，用作数据存储</p>
<h3 id="32-for-of和for-in"><a href="#32-for-of和for-in" class="headerlink" title="32. for of和for in"></a>32. for of和for in</h3><ul>
<li>for of 遍历数组</li>
<li>for in 遍历对象：遍历对象的key或者数组的下标，到原型链查找，遍历新增加的属性的key值，所以不能用于遍历数组。</li>
</ul>
<h3 id="25-js遍历数组的方法（查）"><a href="#25-js遍历数组的方法（查）" class="headerlink" title="25. js遍历数组的方法（查）"></a>25. js遍历数组的方法（查）</h3><ul>
<li><p><strong>for循环，也是最常见的</strong></p>
</li>
<li><pre><code class="js">var arr = [1, 2, 3, 4, 5, 6]
for(var i = 0; i &lt; arr.length; i++) &#123;
    console.log(arr[i])
&#125;
// 1 2 3 4 5 6
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **forEach( function(item,index,array)&#123;&#125;) //当前元素（必须），下标（可选），数组（可选）。** **没有返回值**</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var arr = [1, 2, 3, 4, 5, 6]</span><br><span class="line">    arr.forEach((item, idnex, array) =&gt; &#123;</span><br><span class="line">        console.log(item)     // 1 2 3 4 5 6</span><br><span class="line">        console.log(array)    // [1, 2, 3, 4, 5, 6]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>array.map(function(item, index, array){ }).//当前元素（必须），下标（可选），数组（可选）。</strong> <strong>有返回值</strong></p>
<ul>
<li><pre><code class="js">// 一、会改变原数组
var arr = [1, 2, 3, 4, 5, 6]
var newArr = arr.map(function (item, idnex) &#123;
    return item * item
&#125;)
console.log(arr)      // [1, 2, 3, 4, 5, 6]
console.log(newArr)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **filter**“过滤”、“筛选”, 对数组中的每一项运行给定函数，返回该函数会返回true的想项组成的新数组。指数组filter后，返回过滤后的新数组。</span><br><span class="line"></span><br><span class="line">  与map方法不同的是，filter方法的callback函数需要返回等于true值。如果为true，则通过，否则，不通过。不可以原数组。</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  var arr = [</span><br><span class="line">  	&#123; id: 1, name: &#x27;买笔&#x27;, done: true &#125;,</span><br><span class="line">  	&#123; id: 2, name: &#x27;买笔记本&#x27;, done: true &#125;,</span><br><span class="line">  	&#123; id: 3, name: &#x27;练字&#x27;, done: false &#125;</span><br><span class="line">  ]</span><br><span class="line">      </span><br><span class="line">  var newArr = arr.filter(function (item, index) &#123;</span><br><span class="line">  	return item.done</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(newArr)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>every()，some()</p>
</li>
<li><p>for of </p>
<ul>
<li><pre><code class="js">var arr = [&#39;我&#39;, &#39;是&#39;, &#39;谁&#39;, &#39;我&#39;, &#39;在&#39;, &#39;哪&#39;]
for(var key of arr) &#123;
    console.log(key)
&#125;
// 我 是 谁 我 在 哪
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 33. 数组去重</span><br><span class="line"></span><br><span class="line">- **for循环嵌套，利用splice去重**</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">function newArr(arr)&#123;</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">            if(arr[i]==arr[j])&#123; </span><br><span class="line">            //如果第一个等于第二个，splice方法删除第二个</span><br><span class="line">            arr.splice(j,1);</span><br><span class="line">            j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,2,5,6,3,5,5,6,8,9,8];</span><br><span class="line">console.log(newArr(arr))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>建新数组，利用indexOf去重</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newArr</span>(<span class="params">array</span>)&#123; </span><br><span class="line">    <span class="comment">//一个新的数组 </span></span><br><span class="line">    <span class="keyword">var</span> arrs = []; </span><br><span class="line">    <span class="comment">//遍历当前数组 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++)&#123; </span><br><span class="line">        <span class="comment">//如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 </span></span><br><span class="line">        <span class="keyword">if</span> (arrs.<span class="title function_">indexOf</span>(array[i]) == -<span class="number">1</span>)&#123; </span><br><span class="line">            arrs.<span class="title function_">push</span>(array[i])</span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> arrs; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newArr</span>(arr))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Set去重</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newArr</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newArr</span>(arr))</span><br></pre></td></tr></table></figure>

<h3 id="34-数组排序"><a href="#34-数组排序" class="headerlink" title="34. 数组排序"></a>34. 数组排序</h3><ul>
<li><strong>冒泡排序</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">52</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">57</span>,<span class="number">75</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j =<span class="number">0</span>;j&lt;arr.<span class="property">length</span>-i; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">var</span> temp = arr[j];</span><br><span class="line">			arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">			arr[j+<span class="number">1</span>]=temp; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[1, 2, 3, 8, 52, 57, 75]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sort<strong>排序</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort排序</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">8</span>,<span class="number">12</span>,<span class="number">312</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">n1,n2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n1-n2;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="title function_">sortArray</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//[4, 5, 8, 12, 312]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>选择排序</strong></p>
</li>
<li><pre><code class="javascript">// 选择排序
var arr = [14, 82, 7, 1, 9, 0];
for(var i = 0; i &lt; arr.length - 1; i++)&#123;
    for(var j = i + 1; j &lt; arr.length; j++)&#123;
        if(arr[i] &gt; arr[j])&#123;
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        &#125;
    &#125;
 &#125;
console.log(arr);//[0, 1, 7, 9, 14, 82]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 35. 反转字符串</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function reverseString(str) &#123;</span><br><span class="line">    return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">reverseString(&#x27;hello&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = str.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newString += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reverseString</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">reverseString</span>(str.<span class="title function_">substr</span>(<span class="number">1</span>)) + str.<span class="title function_">charAt</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reverseString</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="35-什么是暂时性死区？"><a href="#35-什么是暂时性死区？" class="headerlink" title="35. 什么是暂时性死区？"></a>35. 什么是暂时性死区？</h3><p>暂时性死区是指，当进入一个作用域，我去使用一个变量名，而这个变量名已经存在了，但是是不可获取的，就会报错，造成暂时性死区问题；比如一个作用域下面使用了 let 定义了 <code>x</code>,但是在定义之前就使用了 <code>x</code>，就会报错；</p>
<h3 id="36-函数柯里化"><a href="#36-函数柯里化" class="headerlink" title="36. 函数柯里化"></a>36. 函数柯里化</h3><p>”函数柯里化”是指将多变量函数拆解为单变量的多个函数的依次调用， 可以从高元函数动态地生成批量的低元的函数。简单讲：就是利用函数执行，可以形成一个不销毁的私有作用域，把预先处理的内容都存在这个不销毁的作用域里面，并且返回一个函数，以后要执行的就是这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的add函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingAdd</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curryingAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="37-null与undefined的区别"><a href="#37-null与undefined的区别" class="headerlink" title="37. null与undefined的区别"></a>37. null与undefined的区别</h3><ul>
<li>null表示⼀个对象可以是null，代表是个空对象，⽽null本身也是对象。<ul>
<li>①用作函数的参数，表示该函数的参数不是对象。</li>
<li>②用作对象原型链的终点。</li>
</ul>
</li>
<li>undefined表示『不存在』，JavaScript是⼀⻔动态类型语⾔，成员除了表示存在的空值外，还有可能根本就不存在(因为存不存在只在运⾏期才知道)，这就是undefined的意义所在。<ul>
<li>①函数没有返回值时，默认返回undefined。</li>
<li>②变量已声明，没有赋值时，为undefined。</li>
<li>③对象中没有赋值的属性，该属性的值为undefined。</li>
<li>④调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
</ul>
</li>
</ul>
<h3 id="38-new-String-a-和String-a"><a href="#38-new-String-a-和String-a" class="headerlink" title="38. new String('a')和String('a')"></a>38. new String('a')和String('a')</h3><ul>
<li>new String('a')：返回的是引用类型，在堆内进行存储，返回值是字符串对象；</li>
<li>String('a')：返回类型是基本类型，在栈内存储，返回的是字符串。</li>
</ul>
<h3 id="39-和-和！！操作符的返回值"><a href="#39-和-和！！操作符的返回值" class="headerlink" title="39. || 和 && 和！！操作符的返回值"></a>39. || 和 && 和！！操作符的返回值</h3><p>两者都会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后在执行条件判断</p>
<ul>
<li>对于||来说，如果条件判断结果为true就返回第一个操作数的值，如果为false就返回第二个操作数的值</li>
<li>&&则相反，如果条件判断结果为true就返回第二个操作数的值，如果为false就返回第一个操作数的值</li>
<li>!!运算符可以将右侧的值强制转换为布尔值，这也是将值转化为布尔值的方法之一</li>
</ul>
<h3 id="40-获取安全的undefined"><a href="#40-获取安全的undefined" class="headerlink" title="40.获取安全的undefined"></a>40.获取安全的undefined</h3><p>因为<code>undefined</code>是一个标识符，所以可以被当做变量来使用和赋值，但是这样会影响<code>undefined</code>的正常判断。</p>
<p>使用void 0来获得undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><ol>
<li><p>新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名;</p>
</li>
<li><p>const/let  都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const一般用于声明常量);</p>
</li>
<li><p>解构赋值, 可以将属性/值从对象/数组中取出，赋值给其他变量。这种语法是 ECMAscript 6 规范引入了一种新语法，可以更轻松地从数组和对象中获取值。</p>
</li>
<li><p>模板字符串(<code>$&#123;data&#125;</code>)</p>
</li>
</ol>
<ul>
<li>比如在处理嵌入表达式、多行字符串、字符串中插入变量、字符串格式化等方面的应用</li>
</ul>
<ol start="5">
<li>扩展运算符(数组、对象);</li>
</ol>
<ul>
<li><strong><code>对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</code></strong></li>
<li>可以将数组转换为参数序列</li>
</ul>
<ol start="6">
<li><p>箭头函数;</p>
</li>
<li><p>Set和Map数据结构;</p>
</li>
</ol>
<ul>
<li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。通过 <em><strong>*add方法*</strong></em> 向 Set 结构加入成员，也可以利用set进行数组去重。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，用作数据存储</li>
</ul>
<ol start="8">
<li><p>Proxy/Reflect;</p>
</li>
<li><p>Promise;</p>
</li>
<li><p>async函数;</p>
</li>
<li><p>Class;</p>
</li>
<li><p>Module语法(import/export)。</p>
</li>
</ol>
<h3 id="1-export-和-export-default-有什么区别"><a href="#1-export-和-export-default-有什么区别" class="headerlink" title="1. export 和 export default 有什么区别"></a>1. export 和 export default 有什么区别</h3><ul>
<li><code>export</code> 是命名导出，每个模块可以命名导出多个。</li>
<li><code>export default</code> 是默认导出，每个模块只能默认导出一个。</li>
<li>使用<code>export</code>导出的使用 <code>import &#123;exportName&#125; from &#39;xxx&#39;</code>来导入。</li>
<li>使用<code>export default </code>导出的使用<code>import xx from &#39;xxx&#39;来导入</code></li>
<li>两者可以同时存在。</li>
</ul>
<h3 id="2-var-let-const区别"><a href="#2-var-let-const区别" class="headerlink" title="2. var/let/const区别"></a>2. var/let/const区别</h3><ul>
<li>var、let 定义的是变量，const 定义的是常量</li>
<li>var 存在变量提升，let const 不存在变量提升</li>
<li>let const 存在块级作用域</li>
<li>const 声明的常量，基本数据类型无法被修改，对象或者数组的可以修改内部的属性值</li>
<li>var 可以重复声明，let，const 在同一个块级作用域中重复声明会报语法错误</li>
<li>浏览器的全局对象是window，Node的全局对象是global。var 声明的变量为全局变量，并且会将改变量添加为全局对象的属性，但是let 和 const 不会。</li>
<li>在使用let const 命令声明变量之前，该变量都是不可用的。在这语法上，称为暂时性死区。使用 var 不会存在暂时性死区。</li>
<li>在变量声明时，let var 可以不用设置初始值。而 const 声明变量必须设置初始值。</li>
</ul>
<h3 id="3-箭头函数和普通函数的区别"><a href="#3-箭头函数和普通函数的区别" class="headerlink" title="3. 箭头函数和普通函数的区别"></a>3. 箭头函数和普通函数的区别</h3><ul>
<li>箭头函数没有自己的this，他会从自己的作用域链的上一层继承this(因此无法使用call / apply / bing 进行绑定this值)</li>
<li>箭头函数没有arguments对象，如果要用，可以用rest参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator 函数</li>
<li>不可以使用new 命令，因为没有自己的this 以及 prototype 属性</li>
</ul>
<h3 id="4-CommonJS模块和ES6模块"><a href="#4-CommonJS模块和ES6模块" class="headerlink" title="4. CommonJS模块和ES6模块"></a>4. CommonJS模块和ES6模块</h3><ul>
<li>CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用，即ES6 Module只存不读，不能改变值，指针指向不能变。</li>
</ul>
<p>共同点：CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。  </p>
<h3 id="5-import-和-require-的区别"><a href="#5-import-和-require-的区别" class="headerlink" title="5. import 和 require 的区别"></a>5. import 和 require 的区别</h3><ul>
<li><strong>遵循规范</strong>：<code>require</code> 是 AMD(异步模块加载机制)，<code>import</code> 是ES6的一个语法标准，如果要兼容的话必须转化成ES5</li>
<li><strong>调用时间</strong>：<code>require</code>是运行时调用， 所以require理论上可以运用在代码的任何地方 ；<code>import</code>是编译时调用，所以必须放在文件开头。</li>
<li><strong>本质</strong>：<code>require</code> 是赋值过程， module.exports后面的内容是什么，require的结果就是什么，比如对象、数字、字符串、函数等，然后再把require的结果赋值给某个变量，它相当于module.exports的传送门 ；<code>import</code>是解构过程。</li>
</ul>
<h3 id="6-Object-defineproperty-和-Proxy"><a href="#6-Object-defineproperty-和-Proxy" class="headerlink" title="6.  Object.defineproperty 和 Proxy"></a>6.  Object.defineproperty 和 Proxy</h3><p> Object.defineproperty 是Vue2实现响应式的原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：劫持对象，对象属性，属性值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//value:18, // 属性值</span></span><br><span class="line">    <span class="comment">//writeable:true, // 是否可以被修改 默认为false,不可以</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以被删除</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 是否可以枚举</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 访问 age 属性时会调用该方法，返回值就是age的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 修改age的值得时候，会调用该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line">******************************************</span><br><span class="line">    </span><br><span class="line">多个数据劫持</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;Hi&#x27;</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys 返回对象的所有的属性</span></span><br><span class="line"><span class="comment">// Object.values 返回对象的所有的属性值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReact</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span><br><span class="line">            get () &#123;</span><br><span class="line">                <span class="keyword">return</span> data[key]</span><br><span class="line">            &#125;,</span><br><span class="line">            set (newValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue === data[key]) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                data[key] = newValue</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 试图更新</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerHTML</span> = data[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineReact</span>()</span><br></pre></td></tr></table></figure>

<p>缺陷：</p>
<ul>
<li>无法检测对象属性的新增和删除。若想实现，则通过Vue.set( (obj, propertName/index, value )或者Vue.delete( obj, propertyName/index )</li>
<li>无法检测到数组的变化。</li>
</ul>
<p>Proxy:是Vue3实现响应式的原理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;dmc&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// info 代理对象</span></span><br><span class="line"><span class="keyword">let</span> infoProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(info, &#123;</span><br><span class="line">    <span class="comment">// target 目标对象</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取对象属性&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置对象属性&#x27;</span>)</span><br><span class="line">    target[key] = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发has捕获器&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：代理整个对象而非对象属性。可以监听数组的变化。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、-跨域问题"><a href="#一、-跨域问题" class="headerlink" title="一、 跨域问题"></a>一、 跨域问题</h2><p>概述：浏览器基于安全因素的考虑，是不允许进行跨域请求的，如果发生跨域请求，就会发生一下类似的错误。</p>
<p>跨域原因：</p>
<ul>
<li>协议：<code>http</code></li>
<li>域名：<code>baidu.com</code></li>
<li>端口号: <code>3000</code></li>
</ul>
<p>解决：解决方案有很多种，比如前端开发时进行<code>反向代理</code>，使用<code>JSONP</code>，后端设置<code>CORS</code>、配置 <code>nginx </code>反向代理等等</p>
<h3 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1. CORS"></a>1. <code>CORS</code></h3><p>概述：跨域资源共享是一种机制，当一个资源访问到另一个资源时，资源就会发起一个跨域的http请求需要浏览器和服务器同时支持：</p>
<p><code>node.js</code>处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 表示允许哪些网站访问，上线后应该直接指定ip而不应该 *</span></span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET, POST, PUT, DELETE&#x27;</span>);</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&#x27;</span>);</span><br><span class="line">      res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);<span class="comment">//和客户端对应，必须设置以后，才能接收cookie.</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2. 反向代理"></a>2. 反向代理</h3><ul>
<li>Vue  config.js中配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 服务器地址</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 本地会虚拟一个服务端接受你的请求并代你发送该请求</span></span><br><span class="line">        <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">// 代理某些 https 服务时用</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>React 在src目录下创建setupProxy.js文件</li>
<li>下载依赖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i http-proxy-middleware -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;createProxyMiddleware&#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">createProxyMiddleware</span>(</span><br><span class="line">    <span class="string">&#x27;/mock&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;^/mock&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3. Nginx"></a>3. Nginx</h3><h2 id="二、HTTP问题"><a href="#二、HTTP问题" class="headerlink" title="二、HTTP问题"></a>二、HTTP问题</h2><p>原理：HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>步骤：客户端连接到Web服务器->发送Http请求->服务器接受请求并返回HTTP响应->释放连接TCP连接->客户端浏览器解析HTML内容</p>
<h3 id="2-1-GET和POST请求"><a href="#2-1-GET和POST请求" class="headerlink" title="2.1 GET和POST请求"></a>2.1 GET和POST请求</h3><ul>
<li>应用场景：GET请求用于对服务器资源不会产生影响的场景。而POST请求一般用于对服务器资源会产生影响的场景。</li>
<li>是否缓存：浏览器一般会对GET请求进行缓存，但很少对POST请求进行缓存。</li>
<li>请求参数：GET请求使用URL进行传递参数，URL的？后面拼接参数，POST请求中的实体报文部分一般为服务器发送的数据。</li>
<li>安全性：因为GET请求的参数是拼接在URL后面的，所以安全性较差，因为请求的URL会被保留在历史记录中，而POST请求安全性较好。</li>
<li>请求长度：浏览器对URL有长度限制，因此会影响GET请求发送数据的长度，而POST请求并没有长度限制。</li>
<li>刷新：GET请求支持刷新和后退，而POST请求每次刷新都会重新发送</li>
<li>参数类型：POST请求的参数传递支持更多的数据类型</li>
</ul>
<h3 id="2-2-HTTP请求头和响应头"><a href="#2-2-HTTP请求头和响应头" class="headerlink" title="2.2 HTTP请求头和响应头"></a>2.2 HTTP请求头和响应头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<h4 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h4><ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<h3 id="2-3-HTTP状态码304"><a href="#2-3-HTTP状态码304" class="headerlink" title="2.3 HTTP状态码304"></a>2.3 HTTP状态码304</h3><p>概述：客户端有缓存情况下的服务端的一种响应客户端性能优化的一种方式</p>
<p>过多的304状态码可能会导致网站快照停止，收录减少，权重下降</p>
<h3 id="2-4-HTTP-1-0-和-HTTP-1-1"><a href="#2-4-HTTP-1-0-和-HTTP-1-1" class="headerlink" title="2.4 HTTP 1.0 和 HTTP 1.1"></a>2.4 HTTP 1.0 和 HTTP 1.1</h3><ul>
<li><strong>连接方面</strong>：1.0默认使用非持久连接，而1.1 默认使用持久连接。1.1通过使用持久连接来使多个http请求复用同一个TCP连接，一次来避免使用非持久连接时每件需要建立链接的时延。</li>
<li><strong>资源请求</strong>：1.0 中会存在一些浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。1.1 则在请求头引入 range 头域，他允许只请资源的某个部分，即返回码是206</li>
<li><strong>缓存方面</strong>： 1.0 主要使用了 header 里的  If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略 </li>
<li>1.1 新增加了 host 字段，用来指定服务器的域名。1.0 中并没有传递主机名。</li>
<li>1.1 新增加了很多的请求方法</li>
</ul>
<h3 id="2-5-HTTP-1-1-和-HTTP-2-0"><a href="#2-5-HTTP-1-1-和-HTTP-2-0" class="headerlink" title="2.5 HTTP 1.1 和 HTTP 2.0"></a>2.5 HTTP 1.1 和 HTTP 2.0</h3><ul>
<li><strong>二进制协议</strong>：1.1 中的豹纹的头信息必须是文本，数据体可以是文本，也可以是二进制。2.0 则是一个彻底的二进制协议，头信息和数据题都是二进制</li>
<li><strong>多路复用</strong>：2.0 实现了多路复用，任然复用TCP连接，但是在一个连接里，客户端和服务器都可以同时发送多喝请求或者回应，而且不用按照顺序一一发送。</li>
<li><strong>数据流</strong>：2.0使用了数据流的概念，因为2.0的数据包是不按顺序发送的，同一个链接里面连续的数据包，可能属于不同的请求。因此，必须对数据包做标记，指出他属于那个请求。2.0将每个请求或回应的所有数据包，成为一个数据流，每个数据流都有一个独一无二的编号。</li>
<li><strong>头信息压缩</strong>： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。 </li>
<li><strong>服务器推送</strong>： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，。</li>
</ul>
<h3 id="2-6-HTTP和HTTPS"><a href="#2-6-HTTP和HTTPS" class="headerlink" title="2.6 HTTP和HTTPS"></a>2.6 HTTP和HTTPS</h3><ul>
<li>HTTPS 协议需要CA证书，费用较高；HTTP协议不需要</li>
<li>HTTP是超文本传输协议，信息是明文传输的；HTTPS则是具有安全性的SSL加密传输协议</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是由SSL和HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="2-7-输入URL后发生了生么"><a href="#2-7-输入URL后发生了生么" class="headerlink" title="2.7 输入URL后发生了生么"></a>2.7 输入URL后发生了生么</h3><ul>
<li><strong>解析URL</strong>：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li>
<li><strong>缓存判断</strong>：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li>
<li><strong>DNS解析</strong>：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
<li><strong>获取MAC地址</strong>：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</li>
<li><strong>TCP三次握手</strong>：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</li>
<li><strong>HTTPS握手</strong>：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li>
<li><strong>返回数据</strong>：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li>
<li><strong>页面渲染</strong>：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li>
<li><strong>TCP四次挥手</strong>：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<h3 id="2-8-请求报文"><a href="#2-8-请求报文" class="headerlink" title="2.8 请求报文"></a>2.8 请求报文</h3><ul>
<li><strong>请求行</strong>： 请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 </li>
<li><strong>请求头部</strong>： 请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分割<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>
</ul>
</li>
<li><strong>空行</strong></li>
<li><strong>请求体</strong>：post put等请求携带的数据</li>
</ul>
<h3 id="2-9-响应报文"><a href="#2-9-响应报文" class="headerlink" title="2.9 响应报文"></a>2.9 响应报文</h3><ul>
<li><strong>响应行</strong>： 由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 </li>
<li><strong>响应头</strong>：响应部首组成</li>
<li><strong>空行</strong></li>
<li><strong>响应体</strong>：服务器响应的数据</li>
</ul>
<h3 id="2-10-URL"><a href="#2-10-URL" class="headerlink" title="2.10 URL"></a>2.10 URL</h3><ul>
<li>协议：访问服务器获取资源时使用的协议</li>
<li>域名：资源服务器主机名或IP地址</li>
<li>端口：资源服务器监听的端口，不同的scheme有不同的默认端口（HTTP使用80作为默认端口）</li>
<li>路径：服务器上的资源路径。路径与服务器和scheme有关</li>
<li>文件名：打开的文件名称</li>
<li>参数：提供给服务器上的值</li>
<li>锚点：打开用户页面时滚动到该锚点位置</li>
</ul>
<h3 id="2-11-常见的状态码"><a href="#2-11-常见的状态码" class="headerlink" title="2.11 常见的状态码"></a>2.11 常见的状态码</h3><ul>
<li>2开头的表示成功<ul>
<li>一般见到的就是200</li>
</ul>
</li>
<li>3开头的表示重定向<ul>
<li>301永久重定向</li>
<li>302临时重定向</li>
<li>304表示可以在缓存中取数据（协商缓存）</li>
</ul>
</li>
<li>4开头表示客户端错误<ul>
<li>403跨域</li>
<li>404请求资源不存在</li>
</ul>
</li>
<li>5开头表示服务端错误<ul>
<li>50</li>
</ul>
</li>
</ul>
<h2 id="三、DNS"><a href="#三、DNS" class="headerlink" title="三、DNS"></a>三、DNS</h2><p>概述： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。 </p>
<p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。 </p>
<p>解析过程：</p>
<ul>
<li><strong>浏览器缓存</strong>：首先在浏览器缓存中查找对应的IP地址，如果查到直接返回，若找不到就继续下一步</li>
<li><strong>本地DNS服务器</strong>： 将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步 </li>
<li><strong>根域名服务器</strong>： 本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址 </li>
<li><strong>顶级域名服务器</strong>： 本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址 </li>
<li><strong>权威域名服务器</strong>： 本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果 </li>
<li>本地DNS服务器将返回的结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
<li>用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
</ul>
<p> 比如要查询 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。 </p>
<h2 id="四、网络模型"><a href="#四、网络模型" class="headerlink" title="四、网络模型"></a>四、网络模型</h2><ul>
<li><strong>应用层</strong>：为应用程序提供服务</li>
<li><strong>表示层</strong>：数据格式转化、数据加密</li>
<li><strong>会话层</strong>：建立、管理和维护会话</li>
<li><strong>传输层</strong>：建立、管理和维护端到端的连接</li>
<li><strong>网络层</strong>：IP选址及路由选择</li>
<li><strong>数据链路层</strong>：提供介质访问和链路管理</li>
<li><strong>物理层</strong>：物理层</li>
</ul>
<h2 id="五、TCP和UDP"><a href="#五、TCP和UDP" class="headerlink" title="五、TCP和UDP"></a>五、TCP和UDP</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">不可靠传输，不使用流量控制和拥塞控制</td>
<td align="center">可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">支持一对一，一对多，多对一和多对多交互通信</td>
<td align="center">只能是一对一通信</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">首部开销小，仅8字节</td>
<td align="center">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">适用于实时应用，例如视频会议、直播</td>
<td align="center">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p><strong>TCP重传机制</strong>： TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 </p>
<p><strong>TCP三次握手</strong>：</p>
<ul>
<li>第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
</ul>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<ul>
<li>第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
</ul>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<ul>
<li>第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<p><strong>三次握手原因</strong>：客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<p><strong>四次挥手</strong>：</p>
<ul>
<li>第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li>第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li>第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li>第四次挥手：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<h2 id="六、缓存问题"><a href="#六、缓存问题" class="headerlink" title="六、缓存问题"></a>六、缓存问题</h2><h3 id="6-1-本地缓存、cookie、token"><a href="#6-1-本地缓存、cookie、token" class="headerlink" title="6.1 本地缓存、cookie、token"></a>6.1 本地缓存、cookie、token</h3><ul>
<li><p>cookie:网站为了标识用户身份而储存在客户端的数据。（不安全，考虑服务器性能适用cookie），每次http求情都会携带 	</p>
</li>
<li><p>localStorage和SessionStorage不会自动的把数据发给服务器，只会在本地保存</p>
</li>
<li><p>session：一般是用来存储用户会话所需的配置和信息，保存在服务端（安全，登录信息保存，其他信息如果需要保留，可以放在cookie中）</p>
</li>
</ul>
<p>存储大小：cookie大小一般不能超过4k，而 **localStorage、SessionStorage比cookie大得多，可以达到5M</p>
<p>有期事件：localStorage关闭浏览器后数据依然保留，除非手动清除，否则一直在</p>
<p>​					sessionStorage关闭浏览器或者标签后即失效</p>
<p>​					cookie一般由 server 设置值及过期时间</p>
<p>​					session的生命周期是间隔的</p>
<h3 id="6-2-浏览器缓存"><a href="#6-2-浏览器缓存" class="headerlink" title="6.2 浏览器缓存"></a>6.2 浏览器缓存</h3><p>浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p>
<p><strong>强缓存</strong>：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<pre><code>    1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
    1. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存
    1. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
</code></pre>
<p>​	当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高</p>
<p><strong>协商缓存</strong>：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用本地缓存的过程，主要有以下两种情况：</p>
<pre><code>1. 协商缓存生效，返回304
1. 协商缓存失效，返回200和请求结果结果
</code></pre>
<h2 id="七、浏览器"><a href="#七、浏览器" class="headerlink" title="七、浏览器"></a>七、浏览器</h2><h3 id="7-1-性能优化"><a href="#7-1-性能优化" class="headerlink" title="7.1 性能优化"></a>7.1 性能优化</h3><ul>
<li>减少http请求次数</li>
<li>对js和css打包，资源合并</li>
<li>适用雪碧图，把请求的icon合并成一张图片</li>
<li>给资源做缓存</li>
<li>图片按需加载（懒加载）</li>
<li>CDN减少打包体积</li>
<li>异步加载js文件</li>
<li>开启gzip打包</li>
<li>路由懒加载，图片懒加载</li>
<li>预渲染和服务端渲染</li>
<li>组件的按需加载</li>
</ul>
<h3 id="7-2-渲染机制"><a href="#7-2-渲染机制" class="headerlink" title="7.2 渲染机制"></a>7.2 渲染机制</h3><ul>
<li><code>HTML</code>被HTML解析器解析成<code>DOM</code> 树</li>
<li><code>css</code>则被css解析器解析成<code>CSSOM </code>树</li>
<li>结合<code>DOM</code>树和<code>CSSOM</code>树，生成一棵渲染树(<code>Render Tree</code>)</li>
<li>.根据生成的渲染树，进行回流（Layout）,得到节点的几何信息（位置，大小）</li>
<li>重绘（Painting）：根据渲染树以及回流得到的几何信息，得到节点的绝对<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%83%8F%E7%B4%A0&spm=1001.2101.3001.7020">像素</a>（像素，背景色，外观等）</li>
<li>Display将像素发送给GPU，展示在页面上</li>
</ul>
<p>回流(重排)： 当<code>DOM</code>的变化影响了元素位置和尺寸大小，浏览器需要重新计算元素的几何属性</p>
<ul>
<li><p>页面第一次加载时进行一次回流</p>
</li>
<li><p>当元素的 width、height、margin、padding、left、top 发生改变的时候会发生回流、</p>
</li>
<li><p>使 DOM节点增减或移动</p>
</li>
<li><p>读写 offset、client、scroll 时，浏览器为了获取这些值，会进行回流操作</p>
</li>
<li><p>使用 <code>window.getComputedStyle</code>的时候</p>
</li>
</ul>
<p>重绘：</p>
<ul>
<li>当改变元素时，只是改变了它的外观，比如背景颜色等，而没有影响到它的布局，这个时候会发生重绘</li>
<li>回流(重排)必将引起重绘；重绘不一定会引起回流(重排)</li>
</ul>
<p>如何避免或减少：</p>
<ul>
<li>避免逐次改变样式，样式统一批量修改</li>
<li>DOM离线处理，减少回流重绘次数<ul>
<li>使用document fragment在DOM Tree之外建立一个子树</li>
<li>position属性控制其脱离文档流</li>
</ul>
</li>
<li>CSS3硬件加速（GPU加速）</li>
</ul>
<h3 id="7-3-XSS和CSRF攻击"><a href="#7-3-XSS和CSRF攻击" class="headerlink" title="7.3 XSS和CSRF攻击"></a>7.3 XSS和CSRF攻击</h3><p>xss：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。<code>跨域脚本攻击</code></p>
<p>防御：</p>
<ul>
<li>编码：对用户输入的数据进行HTML Entity 编码。把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</li>
<li>过滤：移除用户输入的和事件相关的属性。</li>
</ul>
<p>csrf：在未退出A网站的前提下访问B，B使用A的cookie去访问服务器。<code>跨站请求伪造</code></p>
<p>防御：</p>
<ul>
<li>使用验证码或者 token 验证，每次提交表单时需要带上 token（伪造者访问不到），如果 token 不合法，服务器拒绝请求</li>
<li>通过 host+origin 来判断是否为非法用户</li>
<li>给 Cookie 设置 SameSite属性，来限制第三方 Cookie，里面有三个值 strict、lax、none</li>
</ul>
<h3 id="7-4-进程和线程"><a href="#7-4-进程和线程" class="headerlink" title="7.4 进程和线程"></a>7.4 进程和线程</h3><p>进程是程序的一次执行，他占有一片独有的内存空间；可以通过windows任务管理器查看</p>
<p>线程是进程内的一个独立执行单元；是程序执行的一个完整的流程；是CPU的最小的调度单元</p>
<p>【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>处理机分给线程，即真正在处理机上运行的是线程；</p>
<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h3 id="VUE的优点"><a href="#VUE的优点" class="headerlink" title="VUE的优点"></a>VUE的优点</h3><ol>
<li>简单易学</li>
<li>轻量级框架</li>
<li>渐进式引入</li>
<li>双向数据绑定</li>
<li>组件化开发</li>
<li>结构，数据，视图0分离</li>
</ol>
<h3 id="SPA页面："><a href="#SPA页面：" class="headerlink" title="SPA页面："></a>SPA页面：</h3><p>仅在web页面初始化时加载相应的HTML，CSS，JavaScript.一但页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免也免得重新加载。</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>用户体验好，避免了不必要的跳转和重新渲染。</p>
</li>
<li><p>相对对服务器压力小</p>
</li>
<li><p>前后端职责分离，架构清晰。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>初次加载时耗时多</li>
<li>前进后退路由管理</li>
<li>SEO难度较大</li>
</ul>
</li>
</ul>
<h3 id="1-vue双向绑定的原理"><a href="#1-vue双向绑定的原理" class="headerlink" title="1. vue双向绑定的原理"></a>1. vue双向绑定的原理</h3><p>vue是采用数据劫持配合发布者-订阅者的模式的方式，通过Object.defineProperty()来劫持各个属性的getter和setter，在数据发生变动时发布消息给订阅者，触发相应的监听回调。具体为：需要observe的数据对象进行遍历，并对其和子属性添加getter和setter，Dep负责管理数据的依赖列表，compile解析模板指令，生成指令对象，每个指令对象绑定一个watcher对象，会触发getter,收集到dep仓库中，然后数据更新时就会触发setter，这时候相应的watcher对其再次求值，如果值确实发生变化了，就会通知相应的指令，调用指令的update方法，由对DOM做更新，这就实现了数据驱动DOM的变化。同时vue还会对DOM做事件监听，如果DOM发生变化，vue监听到，就会修改相应的data。</p>
<h3 id="Vue单向数据流"><a href="#Vue单向数据流" class="headerlink" title="Vue单向数据流"></a>Vue单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值</p>
<h3 id="2-Vue监听数组"><a href="#2-Vue监听数组" class="headerlink" title="2. Vue监听数组"></a>2. Vue监听数组</h3><p>首先第一点是要看数组里面是不是还存在对象，如果存在对象的话在进行深层遍历是否还依然存在对象，再把对象进行 defineProperty监听。然后数组的改变实质上只是几个方法，什么 pop，unshift，push…Vue 重写了这几个方法，只要在调用这些方法的时候做出回调更新就可以了</p>
<h3 id="3-nextTick"><a href="#3-nextTick" class="headerlink" title="3. nextTick"></a>3. nextTick</h3><p>解释：就是当页面上的元素被重新渲染之后，才会执行回调函数中的代码(涉及事件循环机制)</p>
<p>正是因为Vue是异步更新Dom，所以当我们修改数据之后，Dom节点的内容不会立即修改，我们这样获取Dom节点的新内容的时候，获取的还是旧的内容</p>
<p>应用：1. 想要在Vue生命周期函数中的<code>created()</code>操作DOM可以使用<code>Vue.nextTick()</code>回调函数</p>
<ol start="2">
<li>在数据改变后要执行的操作，而这个操作需要等数据改变后而改变DOM结构的时候才进行操作，需要用到<code>nextTick</code></li>
</ol>
<p><strong>Vue在一个tick中多次更新数据页面只会更新一次</strong></p>
<p>数据 name 被 页面引用，name 会收集到 页面的 watcher；<br>name 被修改时，会通知所有收集到的 watcher 进行更新（watcher.update）；<br>如果name 一时间被修改三次时，按道理应该会通知三次 watcher 更新，那么页面会更新三次，但是最后只会更新一次。<br>这是因为：<br>当数据变化后，把 watcher.update 函数存放进 nextTick 的 回调数组中，并且会做过滤。<br>通过 watcher.id 来判断 回调数组 中是否已经存在这个 watcher 的更新函数不存在，才 push。<br>之后 nextTick时 遍历回调数组，便会执行了更新。</p>
<p>所以当三次修改数据的时候，会 push 回调数组 三个 watcher.update，但是只有第一次是 push 成功的，其他的会被过滤掉，因为已经存在了。<br>所以，不管你修改多少次数据，nextTick 的回调数组中只存在唯一一个 watcher.update，从而页面只会更新一次。</p>
<h3 id="4-Vue生命周期"><a href="#4-Vue生命周期" class="headerlink" title="4. Vue生命周期"></a>4. Vue生命周期</h3><p>实例化创建，初始化数据，编译模板，挂载dom，渲染，数据的更新，渲染以及销毁，vue提供了一些生命周期函数，我们可以编写代码使得vue被实例化的过程中能够完成我们的需求。</p>
<ul>
<li>beforeCreate<ul>
<li>创建之前，此时还没有data和Method</li>
<li>加一些loading效果。</li>
</ul>
</li>
<li>Created<ul>
<li>创建完成，此时data和Method可以使用了,不能访问dom节点</li>
<li>在Created之后beforeMount之前如果没有el选项的话那么此时生命周期结束，停止编译，如果有则继续</li>
</ul>
</li>
<li>beforeMount<ul>
<li>在渲染之前，压面呈现的是未经Vue编译的DOM结构，所有对DOM的操作都不奏效。</li>
</ul>
</li>
<li>mounted<ul>
<li>页面已经渲染完成，，这个时候可以操作DOM了（但是是获取不了元素的高度等属性的，如果想要获取，需要使用<code>nextTick()</code>）</li>
<li>开启定时器，发送网络请求，绑定自定义事件等初始化操作</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>数据是新的，页面是旧的。</li>
</ul>
</li>
<li>updated<ul>
<li>页面与数据保持同步</li>
</ul>
</li>
<li>beforeDestory<ul>
<li>在实例销毁之前，此时data,methods,指令仍然可以使用</li>
<li>关闭定时器，取消订阅消息，解绑自定义事件</li>
</ul>
</li>
<li>destoryed<ul>
<li>实例销毁后</li>
</ul>
</li>
</ul>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<p>nexttick:就是当页面上的元素被重新渲染之后，才会执行回调函数中的代码</p>
<h3 id="5-computed-、watch、method的区别"><a href="#5-computed-、watch、method的区别" class="headerlink" title="5. computed 、watch、method的区别"></a>5. computed 、watch、method的区别</h3><ul>
<li><p>computed</p>
<ul>
<li>计算属性，依赖其他属性，当其他属性改变的时候下一次获取computed值时也会改变，<code>computed</code>的值会有缓存</li>
<li>监控自己定义的变量，改变量不在data中声明，而是在computed里面定义</li>
<li>计算属性不能向服务器发送请求或者执行异步任务</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</li>
<li>定义的变量在data中声明</li>
<li>如果想深度监听的话，后面加一个<code>deep:true</code></li>
<li>如果想监听完立马运行的话，后面加一个<code>immediate:true</code></li>
</ul>
</li>
<li><p>而对于method ，只要发生重新渲染，method 调用总会执行该函数。</p>
</li>
</ul>
<p><code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p>
<h3 id="6-Vue性能优化"><a href="#6-Vue性能优化" class="headerlink" title="6. Vue性能优化"></a>6. Vue性能优化</h3><ol start="4">
<li><p>图片懒加载</p>
<ul>
<li>一张图片就是一个<code>&lt;img&gt;</code>标签，浏览器是否发起请求图片是根据<code>&lt;img&gt;</code>的src属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给<code>&lt;img&gt;</code>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。</li>
</ul>
</li>
<li><p>路由懒加载</p>
<ul>
<li>将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。路由懒加载就是只加载你当前点击的那个模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/login/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/home/home.vue&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"> <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Login</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"> <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/home/home.vue&#x27;</span>) &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>CDN：内容分发网络。采用更多的服务器分布于用户访问相对集中的地方。当用户访问时，就会访问最近的服务器上，响应用户的请求。</p>
</li>
<li><p>使用字体图标代替图片图标</p>
</li>
<li><p>gzip压缩文件：通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。 </p>
</li>
<li><p>长列表虚拟滚动：只渲染可视区域的列表项，非可见区域的不渲染。在滚动时动态更新可视区域。原理：计算出列表的总高度，并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度，以此来从列表数据中截取。</p>
</li>
</ol>
<h3 id="7-Vue-router"><a href="#7-Vue-router" class="headerlink" title="7. Vue-router"></a>7. Vue-router</h3><ul>
<li>vue 的一个插件库，专门用来实现 SPA 应用。原理：检测url的变化，截获url地址，然后解析来匹配路由规则</li>
</ul>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<ul>
<li><p>实现切换：<strong>router-link</strong>,指定展示位置：<strong>router-view</strong>.若是多级路由，可用children进行配置。</p>
</li>
<li><p><strong>两种方式进行传参</strong>：query传参和params进行传参。$router.query.id或者$router.params.id接收参数</p>
</li>
<li><p><strong>router-link的replace属性</strong>：控制路由跳转时操作浏览器历史记录的模式，浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></p>
</li>
<li><p><strong>编程式路由导航</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>keep-alive</strong>：让不展示的路由组件保持挂载，不被销毁</li>
</ul>
<p>缓存多个用数组，缓存一个用字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;News&quot;</span>&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p><strong>activated和deactivated</strong></p>
<p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```deactivated```路由组件失活时触发。</span><br><span class="line"></span><br><span class="line">应用：可以将定时器写在被激活时里，销毁定时器写在失活里，组件跳转时会被触发</span><br><span class="line"></span><br><span class="line">- **路由守卫**：全局守卫(前置和后置)、独享守卫、组件内守卫(进入守卫和离开守卫)</span><br><span class="line"></span><br><span class="line">​		作用：对路由进行权限控制</span><br><span class="line"></span><br><span class="line">​		全局守卫(前置和后置)</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">	console.log(&#x27;beforeEach&#x27;,to,from)</span><br><span class="line">	if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制</span><br><span class="line">		if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则</span><br><span class="line">			next() //放行</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			alert(&#x27;暂无权限查看&#x27;)</span><br><span class="line">			// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		next() //放行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">	console.log(&#x27;afterEach&#x27;,to,from)</span><br><span class="line">	if(to.meta.title)&#123; </span><br><span class="line">		document.title = to.meta.title //修改网页的title</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		document.title = &#x27;vue_test&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>       独享守卫:
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		组件内守卫：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//进入守卫：通过路由规则，进入该组件时被调用</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">//离开守卫：通过路由规则，离开该组件时被调用</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路由模式：</strong></p>
<ul>
<li><h6 id="1-hasn模式"><a href="#1-hasn模式" class="headerlink" title="1. hasn模式"></a>1. hasn模式</h6><ul>
<li><code>hash</code> 模式是一种把前端路由的路径用井号 <code>#</code> 拼接在真实 <code>url</code> 后面的模式。当井号 <code>#</code> 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>onhashchange</code> 事件。不会被包括在 <code>http</code> 请求中。</li>
<li>hash变化会触发网页跳转，即浏览器的前进和后退。</li>
<li><code>hash</code> 通过 <code>window.onhashchange</code> 的方式，来监听 <code>hash</code> 的改变，借此实现无刷新跳转的功能</li>
<li><code>hash</code> 可以改变 <code>url</code> ，但是不会触发页面重新加载，不会出现在``http`中</li>
<li>首先，<code>hash</code>本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，``hash<code>的传参是基于</code>url`的，如果要传递复杂的数据，会有体积的限制</li>
</ul>
<h6 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h6><ul>
<li>利用H5的 history中新增的两个API <code>pushState()</code> 和 <code>replaceState()</code> 和一个事件``onpopstate`监听URL变化</li>
<li><code>history</code>每次刷新会重新像后端请求整个网址，也就是重新请求服务器。如果后端没有及时响应，就会报错404！ </li>
<li><code>history</code>模式不仅可以在``url`里放参数，还可以将数据存放在一个特定的对象中。</li>
<li>修改历史状态：  包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。 </li>
<li>切换历史状态： 包括 <code>forward()</code>、<code>back()</code>、<code>go()</code> 三个方法，对应浏览器的前进，后退，跳转操作。</li>
</ul>
<h6 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h6><ul>
<li>history 模式的 pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>pushState() 可额外设置 title 属性供后续使用。</li>
<li>hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，前端的 url 必须和实际向后端发起请求的 url一致，如果没有对用的路由处理，将返回 404 错误。</li>
</ul>
</li>
<li><p>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</p>
<ul>
<li>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</li>
</ul>
</li>
</ul>
<h3 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8. diff算法"></a>8. diff算法</h3><ul>
<li>diff算法是指对新旧虚拟节点进行对比，并返回一个patch对象，用来存储两个节点不同的地方，最后利用patch记录的消息局部更新DOM</li>
<li>diff 算法<ul>
<li>diff算法是虚拟节点的比较</li>
<li>tag不同认为是不同节点</li>
<li>进行key值的比较</li>
<li>先进行同级比较，</li>
<li>然后再比较是不是一方有儿子，一方没儿子</li>
</ul>
</li>
<li>React和Vue：<ul>
<li>在React中，当数据发生改变的时候，组件数就会自顶向下的全diff，重新render页面，重新生成新的虚拟dom tree，新旧dom tree进行比较，进行打补丁的方式，局部更新dom。所以react为了避免组件更新而引起不必要的子组件更新，可以再shouldComponentUpdate做逻辑判断，减少不必要的render，以及重新生成虚拟dom</li>
<li>react 首先对新集合进行遍历，通过唯一key值来判断新旧集合中是否存在相同的节点，如果没有的话就创建，如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较，如果不同，则进行移动操作，否则就不操作。如果在遍历的过程中，发现在新集合中没有，就会进行删除操作。</li>
<li>在Vue中，通过Object.defineProperty吧data属性全部转为getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep，当dep中的setter被调用时，通知watch重新计算，使得关联组件更新</li>
<li>Vue新旧集合各有头尾的变量，他们的2各变量相互比较，一共有四种比较方式，如果四种都没匹配，则会匹配key值，借助key值找到可复用的节点，在进行相关操作。</li>
</ul>
</li>
</ul>
<h3 id="9-虚拟DOM"><a href="#9-虚拟DOM" class="headerlink" title="9. 虚拟DOM"></a>9. 虚拟DOM</h3><p>概述：本质上是JS和DOM之间的一个映射缓存，它表现为一个能够描述DOM结构及其属性信息的JS对象。主要存储在内存中。</p>
<ul>
<li>虚拟DOM是一个JS对象，存储在内存之中</li>
<li>能够描述真实DOM</li>
<li>当数据变化的时候，生成新的DOM，对比新旧虚拟DOM的差异，将差异更新到 真实DOM上。</li>
</ul>
<p>虚拟DOM优缺点：</p>
<ul>
<li>缺点<ul>
<li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢</li>
</ul>
</li>
<li>优点<ul>
<li>减少了dom操作，减少了回流与重绘</li>
<li>保证性能的下限，但是它具备局部更新的能力，所以大部分时候还是比正常的DOM性能高很多的</li>
</ul>
</li>
</ul>
<h3 id="10-Vue的key（index）"><a href="#10-Vue的key（index）" class="headerlink" title="10. Vue的key（index）"></a>10. Vue的key（index）</h3><ul>
<li>key主要用在虚拟Dom算法中，每个虚拟节点有一个唯一标识Key，通过对比新旧节点的key来判断节点是否改变，用key就可以大大提高渲染效率</li>
<li>使用Index作为key可能会引发的问题<ul>
<li>若对数据进行: 逆序添加, 逆序删除等破坏顺序操作,会产尘没有必要的真实DOM更新, 界面效果没问题, 但效率低</li>
<li>如果结构中还包含输入类的DOM, 例如 input 标签,会产生错误DOM更新, 界面有问题</li>
</ul>
</li>
</ul>
<h3 id="11-vue组件之间的通信（vuex）"><a href="#11-vue组件之间的通信（vuex）" class="headerlink" title="11. vue组件之间的通信（vuex）"></a>11. vue组件之间的通信（vuex）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999687348120190983#heading-15">https://juejin.cn/post/6999687348120190983#heading-15</a></p>
<ul>
<li><p>父传子</p>
<ul>
<li>父组件设置<code>v-bind:</code>/<code>:</code>,子组件设置<strong>props</strong>接受 + <strong>不能直接修改</strong>父组件的数据</li>
<li>使用**.sync<strong>通信，:num.sync="num" ,子组件用props接收传递的值(绑定的属性名自己决定) 在子组件中通过$emit方法触发<code>&#39;update:属性名&#39;</code>事件 实现父组件子组件值同时变化</strong>this.$emit('update:属性名',要修改的值)**@update:num</li>
<li>使用<strong>v-model</strong>通信，v-model="num",  ,子组件用props接收传递的值value, 在子组件中通过$emit方法触发input事件 实现父组件子组件值同时变化  **<code>this.$emit(&#39;input&#39;,this.value+1)</code></li>
</ul>
</li>
<li><p>子传父</p>
<ul>
<li>自定义事件：在父组件v-on绑定自定义事件，在子组件通过$emit触发事件，第一个参数为事件名称，第二个参数为要传递的参数。</li>
<li>通过父组件给子组件传递函数类型的props实现：子给父传递</li>
</ul>
</li>
<li><p><strong>ref</strong> 如果在普通的DOM元素上，引用指向的就是该DOM元素;</p>
<p>如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 $ref 主动获取子组件的属性或者调用子组件的方法</p>
</li>
<li><p>任意组件</p>
<ul>
<li><p>传说中的**$bus**</p>
<ul>
<li><pre><code class="js">new Vue(&#123;
    ......
    beforeCreate() &#123;
        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    &#125;,
    ......
&#125;) 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">使用：*在需要向外部发送自定义事件的组件内*通过this.$bus.$emit发送数据</span><br><span class="line">  </span><br><span class="line">*在需要接收外部事件的组件内*通过$on监听事件的触发并接受数据。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">methods()&#123;</span><br><span class="line">  demo(data)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$bus.$on(&#x27;xxxx&#x27;,this.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>Vuex</p>
<ul>
<li>集中式存储管理所有组件的状态</li>
</ul>
</li>
<li><p>[<a target="_blank" rel="noopener" href="https://juejin.cn/post/6928468842377117709#heading-8]">https://juejin.cn/post/6928468842377117709#heading-8]</a>: </p>
<ul>
<li>state<ul>
<li>存储数据的</li>
<li>获取数据最好推荐使用getters</li>
<li>硬要使用的话可以用MapState， 先引用，放在compute中<code>...mapState([&#39;方法名&#39;,&#39;方法名&#39;])</code></li>
</ul>
</li>
<li>getters<ul>
<li>. 值为一个对象，包含多个用于返回数据的函数。函数第一个参数为state</li>
<li>对state中的数据进行操作和加工，</li>
</ul>
</li>
<li>mutations<ul>
<li>同步操作数据的</li>
<li>值为一个对象，包含多个响应用户动作的回调函数</li>
<li>组件中使用this.$store.commit(“方法名”,数据)触发</li>
<li>也可使用mapMutations ，使用方法和以上一样</li>
</ul>
</li>
<li>actions<ul>
<li>异步操作数据的</li>
<li>值为一个对象，包含多个响应用户动作的回调函数</li>
<li>通过 commit( )来触发 mutation 中函数的调用</li>
<li>组件中使用this.$store.dispatch(“方法名”,数据)触发 </li>
<li>也可使用mapActions ，使用方法和以上一样</li>
</ul>
</li>
<li>modules<ul>
<li>一个 module 是一个 store 的配置对象</li>
</ul>
</li>
</ul>
<p>引用vuex:</p>
<ul>
<li><p>先安装依赖<code>nnpm install vuex --save</code></p>
</li>
<li><p>在项目目录src中建立store文件夹</p>
</li>
<li><p>在store文件夹下新建index.js文件,写入</p>
</li>
<li><pre><code class="js">import Vue from &#39;vue&#39;;
import Vuex from &#39;vuex&#39;;
Vue.use(Vuex);
//不是在生产环境debug为true
const debug = process.env.NODE_ENV !== &#39;production&#39;;
//创建Vuex实例对象
const store = new Vuex.Store(&#123;
    strict:debug,//在不是生产环境下都开启严格模式
    state:&#123;
    &#125;,
    getters:&#123;
    &#125;,
    mutations:&#123;
    &#125;,
    actions:&#123;
    &#125;
&#125;)
export default store;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 然后再main.js文件中引入Vuex,这么写</span><br><span class="line">  </span><br><span class="line">- ```js</span><br><span class="line">  import Vue from &#x27;vue&#x27;;</span><br><span class="line">  import App from &#x27;./App.vue&#x27;;</span><br><span class="line">  import store from &#x27;./store&#x27;;</span><br><span class="line">  const vm = new Vue(&#123;</span><br><span class="line">      store:store,</span><br><span class="line">      render: h =&gt; h(App)</span><br><span class="line">  &#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>vuex的 store 中的数据是保存在运行内存中的，当页面刷新时，页面会重新加载 vue 实例，vuex 里面的数据就会被重新赋值，这样就会出现页面刷新vuex中的数据丢失的问题。 如何解决浏览器刷新数据丢失问题呢？</strong></p>
<ol>
<li>方法一：全局监听，页面刷新的时候将 store 里 state 的值存到 sessionStorage 中，然后从sessionStorage 中获取，再赋值给 store ，并移除 sessionStorage 中的数据。</li>
<li>安装 vuex-persistedstate 插件，在vuex实例对象后添加插件</li>
</ol>
<p>vuex-persistedstate 默认使用 localStorage 来存储数据，若要实现无痕浏览该如何实现呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">persistedState</span>(&#123; <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span> &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="12-Vue-router有哪几种钩子函数"><a href="#12-Vue-router有哪几种钩子函数" class="headerlink" title="12. Vue-router有哪几种钩子函数"></a>12. <strong>Vue-router有哪几种钩子函数</strong></h3><p>全局守卫(前置和后置)、独享守卫、组件内守卫(进入守卫和离开守卫)</p>
<ul>
<li><p>beforeEach(全局前置守卫)</p>
<ul>
<li>初始化时执行、每次路由切换前执行</li>
<li>判断当前路由是否需要进行权限控制</li>
</ul>
</li>
<li><p>afterEach(全局后置守卫)</p>
<ul>
<li>初始化时执行、每次路由切换后执行</li>
</ul>
</li>
<li><p>beforeRouterLeave</p>
</li>
</ul>
<h3 id="13-为什么组件中-data-是个函数"><a href="#13-为什么组件中-data-是个函数" class="headerlink" title="13. 为什么组件中 data 是个函数"></a>13. <strong>为什么组件中 data 是个函数</strong></h3><p>在 Vue 底层中，在每次创建组件的时候，都会 new 一个VueComponent实例对象，他们的 data会挂载到VueComponent 的原型上共享，如果是一个对象的话，所有人都可以修改，但是如果是一个函数返回值的话就可以创建一个私有作用域来避免互相污染。</p>
<h3 id="14-v-model"><a href="#14-v-model" class="headerlink" title="14. v-model"></a>14. v-model</h3><p>语法糖，v-bind绑定响应式数据，v-on触发事件并触发数据。用于表单数据的双向绑定。监听用户的输入事件已更新数据，初始值为VUE实例的数据作为数据来源。父子组件中使用v-model通信 ,子组件用props接收传递的值value(一定要叫value) 在子组件中通过$emit方法触发input事件 实现父组件子组件值同时变化</p>
<p>组件绑定<code>v-model</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="title class_">Component</span> v-model=<span class="string">&#x27;data&#x27;</span>&gt;&lt;/<span class="title class_">Component</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">	name:&#x27;Component&#x27;,</span><br><span class="line">        model:&#123;</span><br><span class="line">           prop: &#x27;checked&#x27;,</span><br><span class="line">    	event: &#x27;change&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            checked:Boolean</span><br><span class="line">        &#125;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-v-html和v-text"><a href="#15-v-html和v-text" class="headerlink" title="15. v-html和v-text"></a>15. v-html和v-text</h3><p>浏览器解析不出html代码，会将它当做普通文本。v-html就可以解析为标签，而v-text只会解析为文本。</p>
<p>v-html可能会造成xss攻击，v-html 会替换掉子标签</p>
<h3 id="17-vue2-0和3-0"><a href="#17-vue2-0和3-0" class="headerlink" title="17. vue2.0和3.0"></a>17. vue2.0和3.0</h3><p>vue2 的双向数据绑定是利用ES5 的一个 API ，Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。<br>vue3 中使用了 es6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每一个对象都包一层 Proxy，通过 Proxy 监听属性的变化，从而实现对数据的监控。</p>
<ul>
<li>可以监听动态新增的属性；</li>
<li>可以监听删除的属性 ；</li>
<li>可以监听数组的变化；</li>
</ul>
<p>采用ts编写</p>
<p><strong>使用proxy的优势</strong></p>
<ol>
<li>可直接监听数组类型的数据变化</li>
<li>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</li>
<li>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行</li>
<li>直接实现对象属性的新增/删除</li>
</ol>
<h3 id="18-vue的-set"><a href="#18-vue的-set" class="headerlink" title="18. vue的$set"></a>18. <strong>vue的$set</strong></h3><p>vue 中 data的数据，如果是对象的话，会把它的属性转为Object.defineProperty的getter和setter，使之变为响应式的。</p>
<p><strong>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</strong>,比如data中有一个对象具有name和sex属性，想追加一个age属性，增加成功但是不贵在视图上进行显示。因为在创建实例的时候 缺少了vue 监听的 set、get属性(直接在mounted中，用<code>$set</code>方法添加进去)<code>this.$set(this.student,&quot;age&quot;,24)</code></p>
<h3 id="19-v-if和v-for"><a href="#19-v-if和v-for" class="headerlink" title="19. v-if和v-for"></a>19. v-if和v-for</h3><p>在v-if和v-for用在同一个元素上时，因为v-for要比v-if的优先级高，所以会先执行循环，再进行判断，这样无论条件判断的结果如何，循环都会执行。所以要避免她们用在一起，如果需要的话，可以在外层加一个template，v-if用在template上，这样就可以实现先判断再根据判断结果决定是否执行循环了。</p>
<h3 id="20-v-if-和-v-show"><a href="#20-v-if-和-v-show" class="headerlink" title="20. v-if 和 v-show"></a>20. <strong>v-if 和 v-show</strong></h3><p>v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p>
<p>v-show适合频繁切换,v-if适合运行条件不大可能改变</p>
<h3 id="21-插槽"><a href="#21-插槽" class="headerlink" title="21. 插槽"></a>21. 插槽</h3><p>Slot 通俗的理解就是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑</p>
<p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式</p>
<p>作用域插槽：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定，通过 “slot-scope” 来接收子组件传过来的插槽数据，再根据插槽数据来填充插槽的内容</p>
<h3 id="22-自定义事件"><a href="#22-自定义事件" class="headerlink" title="22. 自定义事件"></a>22. 自定义事件</h3><p>一种组件间通信的方式</p>
<ol>
<li>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</li>
<li>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>		</li>
<li>解绑自定义事件```this.$off('atguigu')`</li>
</ol>
<h3 id="23-在使用计算属性时，函数名与data中的数据名可以同名吗"><a href="#23-在使用计算属性时，函数名与data中的数据名可以同名吗" class="headerlink" title="23. 在使用计算属性时，函数名与data中的数据名可以同名吗"></a>23. 在使用计算属性时，函数名与data中的数据名可以同名吗</h3><p>不可以。</p>
<p>在初始化的时，props、methods、data、computed、watch会依次绑定到vm上，因此，当方法名与数据名重复时，会覆盖掉上一个。</p>
<h3 id="24-vue打包后静态资源路径"><a href="#24-vue打包后静态资源路径" class="headerlink" title="24. vue打包后静态资源路径"></a>24. vue打包后静态资源路径</h3><p> 1、确定线上环境是否在根路径上，配置资源根目录，vue-cli2 和 vue-cli3 字段不一致（assetsPublicPath 和 publicPath ），如果项目是根路径上，用'/'，'./'都行，如果是在'/hc'这个路径上，用'./' 相对路径（需history模式），也可以用'/hc/'。 在'/hc'路径上，如果需要本地和线上保持一致，可以用环境做判断设置不同的publicPath值。<br>2、确定静态文件放置的位置。<br>①、如果放在public/static，不经过webpack打包， 放在public 又分使用绝对路径和相对路径。<br>②、如果放在assets， 经过webpack打包， 使用的是相对路径<br>3、路径是否是动态的，如果是动态，需要用require() 引入。 </p>
<h3 id="25-vue动态设置img"><a href="#25-vue动态设置img" class="headerlink" title="25. vue动态设置img"></a>25. vue动态设置img</h3><p><code>&lt;img :src=&quot;require(@/assets/images/xxx.png&#39;)&quot; /&gt;  </code></p>
<h3 id="26-vue-中created和mounted请求数据"><a href="#26-vue-中created和mounted请求数据" class="headerlink" title="26. vue 中created和mounted请求数据"></a>26. vue 中created和mounted请求数据</h3><p>created比mounted提前，一般在created中发送请求就可以但无法操作dom，如果涉及到需要页面加载完成之后的话就用mounted。</p>
<h3 id="27-多个后端接口"><a href="#27-多个后端接口" class="headerlink" title="27. 多个后端接口"></a>27. 多个后端接口</h3><p>devServer中把所有的服务人员的地址代理都写进去，然后动态地更改接口的baseUrl</p>
<h3 id="28-render-template-el"><a href="#28-render-template-el" class="headerlink" title="28. render>template>el"></a>28. render>template>el</h3><p>****1.****当Vue选项对象中有render渲染函数时，Vue构造函数将直接使用渲染函数渲染DOM树。</p>
<p>****2.****当选项对象中没有render渲染函数时：Vue构造函数首先通过将template模板编译生成渲染函数，然后再渲染DOM树。</p>
<p>****3.*<em><strong>而当Vue选项对象中既没有render渲染函数，也没有template模板时，会</strong></em>*通过el属性获取****挂载元素的outerHTML来作为模板，并编译生成渲染函数。</p>
<p>换言之，在进行DOM树的渲染时，render渲染函数的优先级最高，template次之且需编译成渲染函数，而挂载点el属性对应的元素若存在，则在前两者均不存在时，其outerHTML才会用于编译与渲染。</p>
<h3 id="29-template编译模板"><a href="#29-template编译模板" class="headerlink" title="29. template编译模板"></a>29. template编译模板</h3><p> vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段：</p>
<ul>
<li><strong>解析阶段</strong>： 使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。 </li>
<li><strong>优化阶段</strong>： 遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。 </li>
<li><strong>生成阶段</strong>： 将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="30-Vue首页白屏渲染"><a href="#30-Vue首页白屏渲染" class="headerlink" title="30. Vue首页白屏渲染"></a>30. Vue首页白屏渲染</h3><ul>
<li>路由懒加载：当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验。使用ES6的动态加载模块--<code>import()</code></li>
<li>组件懒加载：当组件复用性很高或者JS文件较大时或者用户触发时，才会加载该组件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dialogInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;dialogInfo&quot; */</span> <span class="string">&#x27;@/components/dialogInfo&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;homeView&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    dialogInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>骨架屏：在项目打包时将骨架屏的内容放到 html 文件的根节点中。</li>
<li>长列表虚拟滚动：只渲染可视区域的列表项，非可见区域的不渲染。在滚动时动态更新可视区域。<ul>
<li>原理：计算出列表的总高度，并在触发滚动事件时根据滚动长度实时更新预留缓冲区域高度，以此来从列表数据中截取。</li>
</ul>
</li>
<li>图片懒加载： 由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性 。</li>
<li>JS 异步加载：defer 是渲染完在执行，async 是加载完就执行。</li>
<li>图片转base64格式.</li>
<li>Web Woeker 优化长任务。</li>
</ul>
<h3 id="31-Vue为什么只有一个根元素"><a href="#31-Vue为什么只有一个根元素" class="headerlink" title="31. Vue为什么只有一个根元素"></a>31. Vue为什么只有一个根元素</h3><p>创建Vue实例时，只能有一个入口，也就是一个根节点，再通过此根节点来递归遍历所有节点。这也是diff算法所必需的。</p>
<h3 id="32-Vue数据发生改变页面会更新吗？如何实现异步更新的"><a href="#32-Vue数据发生改变页面会更新吗？如何实现异步更新的" class="headerlink" title="32. Vue数据发生改变页面会更新吗？如何实现异步更新的"></a>32. Vue数据发生改变页面会更新吗？如何实现异步更新的</h3><ul>
<li>Vue 不会检测到实例创建时不存在与data中的变量的改变。</li>
<li>Vue 不会检测到data 中对象属性的动态添加和删除。</li>
<li>无法通过数组索引或者赋值，也无法直接改变数组的长度。</li>
<li>异步获取接口数据，DOM 结构不发生变化。</li>
</ul>
<p>实现： Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 </p>
<h3 id="33-Vue的render函数"><a href="#33-Vue的render函数" class="headerlink" title="33. Vue的render函数"></a>33. Vue的render函数</h3><p>VNode 虚拟DOM到真实DOM的过程，实现mount方法挂载(遍历整个DOM树，构建出真实的DOM树)，接收三个参数，节点，属性，子节点，通过判断生成一个真实的DOM元素。</p>
<h3 id="34-MVVM，MVC的理解"><a href="#34-MVVM，MVC的理解" class="headerlink" title="34. MVVM，MVC的理解"></a>34. MVVM，MVC的理解</h3><ul>
<li>Model：模型。</li>
<li>View：视图。</li>
<li>ViewModel：视图模型。MVVM的核心，主要用来处理业务逻辑。<ul>
<li>当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新 </li>
<li>当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动， 实现了数据的双向绑定</li>
</ul>
</li>
</ul>
<p>MVC的C为控制层，缺点：所有的业逻辑都在控制层中处理，不利于维护，不适合小型和中型项目。</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-React中key的作用"><a href="#1-React中key的作用" class="headerlink" title="1. React中key的作用"></a>1. React中key的作用</h2><p> keys是React用于追踪那些列表重元素被修改，呗添加或者被移除的辅助标识。</p>
<ul>
<li>React利用key来识别组件，相同的key react认为是同一个组件，这样相同的key对应组件就不会被创建。</li>
<li>有了key属性，就可以与组件建立了一种对应关系，react根据key来决定销毁重新创建组件还是更新组件。</li>
<li>key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。</li>
<li>key值不同，则react先销毁该组件，然后重新创建该组件，</li>
</ul>
<h2 id="2-React的设计思想"><a href="#2-React的设计思想" class="headerlink" title="2. React的设计思想"></a>2. React的设计思想</h2><ul>
<li>组件化。每个组件都符合开放封闭原则，封闭是针对渲染工作流来说的，指的是组件内部的状态有自身维护，只处理内部的渲染逻辑。开放是针对组件通信来说的，指的是不同组件可以通过props来进行数据交互。</li>
<li>数据驱动视图。如果要渲染界面，不应该直接操作DOM，而是通过修改数据的方式来驱动视图更新。</li>
<li>虚拟DOM。虚拟DOM是对真实DOM的印射，React通过新旧虚拟DOM对比，得到需要更新的部分。</li>
</ul>
<h2 id="3-JSX是什么，和JS的区别"><a href="#3-JSX是什么，和JS的区别" class="headerlink" title="3. JSX是什么，和JS的区别"></a>3. JSX是什么，和JS的区别</h2><p>JSX是react的语法糖，他允许在html中写JS，不能瘪浏览器直接识别，需要通过webpack babel编译工具转化为JS执行。</p>
<p>区别：</p>
<ul>
<li>JS可以被打包工具直接编译，不需要额外转换，jsx需要通过babel编译，他是 React.createElement 的语法糖。</li>
<li>jsx是js的语法扩展，允许在html中写JS；JS是原生写法，需要通过script标签引入。</li>
</ul>
<p> <strong>为什么在文件中没有使用react，也要在文件顶部import React from “react”</strong> </p>
<p>只要使用了jsx，就需要引用React，因为jsx本质上就是React.createElement</p>
<p> <strong>为什么React自定义组件首字母要大写</strong> </p>
<p>jsx通过babel转义时，调用了React.createElement函数，他接受三个参数，分别是 分别是type元素类型，props元素属性，children子元素。 </p>
<p>如果组件首字母为小写，则会被当成字符串进行传递，在创建虚拟DOM的时候，就会把它当成一个html标签。而如果是大写，就会当成一个变量进行传递，React知道他是个自定义组件。</p>
<h2 id="3-React组建为什么只能有一个根元素，为什么不能返回多个元素"><a href="#3-React组建为什么只能有一个根元素，为什么不能返回多个元素" class="headerlink" title="3. React组建为什么只能有一个根元素，为什么不能返回多个元素"></a>3. React组建为什么只能有一个根元素，为什么不能返回多个元素</h2><ul>
<li>React组件最后会被编译为render函数，函数的返回值只能是一个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的。</li>
<li>react的虚拟DOM是一个树状结构，树的根节点只能是一个，如果有多个根节点，则无法确认实在那棵树上进行更新。</li>
</ul>
<h2 id="4-React-Fragment"><a href="#4-React-Fragment" class="headerlink" title="4. React.Fragment"></a>4. React.Fragment</h2><p>可以将元素列表加到一个分组中，而且不会创建额外的节点。</p>
<h2 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5. React的生命周期"></a>5. React的生命周期</h2><p>生名周期指的是组件实例从创建到销毁的流程，函数组件没有生命周期，只有类组件才有，因为只有class组件才会创建组件实例。</p>
<ul>
<li>挂载。 <strong>constructor</strong> 可以进行state和props的初始化 。<strong>componentDidMount</strong>第一次渲染调用，可以访问DOM，进行异步请求和定时器。</li>
<li>更新。 <strong>shouldComponentUpdate</strong> 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用  <strong>componentDidUpdate</strong> 在组件完成更新后调用 </li>
<li>卸载。 <strong>componentWillUnmount</strong> 组件从DOM中被移除的时候调用 </li>
<li>错误捕获。 static getDerivedStateFromError 在<strong>errorBoundary</strong>中使用</li>
</ul>
<h2 id="6-React-事件机制"><a href="#6-React-事件机制" class="headerlink" title="6. React 事件机制"></a>6. React 事件机制</h2><p>React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发，事件冒泡，事件捕获，事件 合成和事件派发等。</p>
<ul>
<li>React所有的事件绑定在container(document)上，而不是绑定在目标元素上，减少了内存开销。</li>
<li>React自身实现了一套冒泡机制，不能通过return false 阻止冒泡</li>
<li>React 通过SytheticEvent实现了时间合成。</li>
</ul>
<h2 id="7-React事件处理为什么要手动绑定this"><a href="#7-React事件处理为什么要手动绑定this" class="headerlink" title="7. React事件处理为什么要手动绑定this"></a>7. React事件处理为什么要手动绑定this</h2><p>React组件会被编译为React.createElement，在createElement中，他的this丢失了，并不是有组件实例调用的，因此需要手动绑定this.</p>
<h2 id="8-useEffect和useLayoutEffect区别"><a href="#8-useEffect和useLayoutEffect区别" class="headerlink" title="8. useEffect和useLayoutEffect区别"></a>8. useEffect和useLayoutEffect区别</h2><h2 id="9-React性能优化手段"><a href="#9-React性能优化手段" class="headerlink" title="9. React性能优化手段"></a>9. React性能优化手段</h2><ul>
<li>shouldComponentUpdate</li>
<li>memo</li>
<li>getDerviedStateFromProps</li>
<li>使用Fragment</li>
<li>v-for使用正确的key</li>
<li>拆分尽可能小的可复用组件，使用错误边界ErrorBoundary</li>
<li>使用React.lazy和React.Suspense延迟加载不需要立马使用的组件</li>
</ul>
<h2 id="10-Portal"><a href="#10-Portal" class="headerlink" title="10. Portal"></a>10. Portal</h2><p>Portal提供了让子组件渲染在除了父组件之外的DOM节点的方式，他接受两个参数，第一个元素是需要渲染的React元素，第二个是渲染的地方(DOM元素)</p>
<p><code>ReactDom.createPortal(child,container)</code></p>
<h2 id="11-React组件通信"><a href="#11-React组件通信" class="headerlink" title="11. React组件通信"></a>11. React组件通信</h2><h3 id="11-1-props"><a href="#11-1-props" class="headerlink" title="11.1 props"></a>11.1 props</h3><p>概述：父组件传递给子组件的数据，子组件不能修改该数据，在 <code>class </code>组件中通过 <code>this.props </code>的方式获取。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;welcome&#x27;</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">    &lt;<span class="title class_">Welcome</span> msg=<span class="string">&quot;Hi Props&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>peops约束：因为从 React 15.x 开始移除了 props 约束，所以需要安装第三方模块实现</p>
<p><code>nom i --save prop-types</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;welcome&#x27;</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Welcome</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">    <span class="attr">msg</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-子传父"><a href="#11-2-子传父" class="headerlink" title="11.2 子传父"></a>11.2 子传父</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 </span></span><br><span class="line">callback = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">    &lt;<span class="title class_">Button</span> callback=&#123;callback&#125;&gt;</span><br><span class="line">    &lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件 </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">callback</span>(<span class="string">&#x27;传递给父组件数据&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-3-Context"><a href="#11-3-Context" class="headerlink" title="11.3 Context"></a>11.3 Context</h3><p>Context提供了一种跨层级组建数据传递的方法，他解决了组件嵌套造成数据来源不清晰，多余的变量定义等问题。</p>
<p>使用：</p>
<ol>
<li>新建 <code>context</code>文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([]) <span class="comment">// 创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyContext</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建<code>Provider</code> 组件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      msg,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  addList = <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">list</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>, todo],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>,</span><br><span class="line">      <span class="attr">list</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>,</span><br><span class="line">      <span class="attr">changeMsg</span>: <span class="variable language_">this</span>.<span class="property">changeMsg</span>,</span><br><span class="line">      <span class="attr">addList</span>: <span class="variable language_">this</span>.<span class="property">addList</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>class 组件使用 value</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;value.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数组件使用</li>
</ol>
<p>概述： 允许在函数组件中使用 context 对象，在 context 值发生改变时重新渲染。</p>
<p>问题：context 的值发生改变，无论子组件是否引用 value， 都会导致 子组件重新渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>); <span class="comment">// 需要接受context作为参数</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;context.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4-UseReducer"><a href="#11-4-UseReducer" class="headerlink" title="11.4 UseReducer"></a>11.4 UseReducer</h3><p>概述： useReducer 是 useState 的替代方案，能够解决 useState 状态更新逻辑散落在 UI 中，不能独立复用，不方便测试。</p>
<p>使用：</p>
<ol>
<li>新建<code>FnProvider</code>组件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoReducer <span class="keyword">from</span> <span class="string">&#x27;./todoReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FnProvider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [msg, changeMsg] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">//   const [todoList, setTodoList] = useState([])</span></span><br><span class="line">  <span class="keyword">const</span> [todoList, dispatch] = <span class="title function_">useReducer</span>(todoReducer, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>FnProvider<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">msg</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">changeMsg</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">todoList</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">dispatch</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建<code>reducer.js</code>文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">todoReducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.<span class="property">todo</span>]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> !== action.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;EDIT&#x27;</span>:</span><br><span class="line">      <span class="keyword">const</span> index = state.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === action.<span class="property">payload</span>.<span class="property">id</span>) <span class="comment">// 返回下标</span></span><br><span class="line">      <span class="keyword">const</span> newTodoList = [...state]</span><br><span class="line">      newTodoList.<span class="title function_">splice</span>(index, <span class="number">1</span>, action.<span class="property">payload</span>.<span class="property">todo</span>)</span><br><span class="line">      <span class="keyword">return</span> newTodoList</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">FnProvider</span> <span class="keyword">from</span> <span class="string">&#x27;./store/FnProvider&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">FnProvider</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line">  &lt;/<span class="title class_">FnProvider</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line"></span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span></span><br><span class="line">          context.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;DEL&#x27;</span>,</span><br><span class="line">            <span class="attr">id</span>: item.<span class="property">id</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-5-Redux"><a href="#11-5-Redux" class="headerlink" title="11.5 Redux"></a>11.5 Redux</h3><p>Redux是一个状态管理库，应用于跨层级组建数据共享与通信，一些需要持久化的全局数据，比如用户登录信息。</p>
<p>新项目：</p>
<p><code>npx create-react-app 项目名 --template redux</code></p>
<p><code>npx create-react-app 项目名 --template redux-typescript</code></p>
<p>老项目：</p>
<p><code>npm i redux react-redux</code></p>
<h5 id="11-5-1-项目引入"><a href="#11-5-1-项目引入" class="headerlink" title="11.5.1 项目引入"></a>11.5.1 项目引入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">reportWebVitals</span>();</span><br></pre></td></tr></table></figure>

<h5 id="11-5-2-store-创建"><a href="#11-5-2-store-创建" class="headerlink" title="11.5.2 store 创建"></a>11.5.2 store 创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer/reducer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoReduce <span class="keyword">from</span> <span class="string">&#x27;./reducer/todoReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: reducer,</span><br><span class="line">  <span class="attr">todo</span>: todoReduce,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(mainReducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测 state 的变化</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生改变&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-5-3-reducer"><a href="#11-5-3-reducer" class="headerlink" title="11.5.3 reducer"></a>11.5.3 reducer</h5><p>概述：是一个纯函数，会根据不同的 action 对象返回一个新的 state</p>
<p>纯函数：</p>
<ul>
<li>不修改传入的参数</li>
<li>不执行有副作用的操作，比如API，计时器等等</li>
<li>不调用非纯函数，如<code>new Date()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;练习篮球一年半&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addActionType = <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTodo</span> = (<span class="params">payload</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: addActionType,</span><br><span class="line">    payload,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editActionType = <span class="string">&#x27;EDIT&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">editTodo</span> = (<span class="params">payload</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: editActionType,</span><br><span class="line">    payload,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DelType</span> = <span class="string">&#x27;DEL&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">actionDel</span> = (<span class="params">payload</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">DelType</span>,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">todoReduce</span>(<span class="params">state = initData, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">addActionType</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, payload]</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DelType</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> !== payload.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">editActionType</span>:</span><br><span class="line">      <span class="keyword">const</span> index = state.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === payload.<span class="property">id</span>) <span class="comment">// 返回下标</span></span><br><span class="line">      <span class="keyword">const</span> newTodoList = [...state]</span><br><span class="line">      newTodoList.<span class="title function_">splice</span>(index, <span class="number">1</span>, payload)</span><br><span class="line">      <span class="keyword">return</span> newTodoList</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-5-4-combineReducers"><a href="#11-5-4-combineReducers" class="headerlink" title="11.5.4 combineReducers"></a>11.5.4 combineReducers</h5><p>概述：用于将多个 reducer 合并为一个 reducer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">    home,</span><br><span class="line">    user,</span><br><span class="line">    todo</span><br><span class="line">&#125;)</span><br><span class="line">store = <span class="title function_">createStore</span>(mainReducer)</span><br></pre></td></tr></table></figure>

<h5 id="11-5-5-useSelector"><a href="#11-5-5-useSelector" class="headerlink" title="11.5.5 useSelector"></a>11.5.5 useSelector</h5><p>概述：用于组件中获取 state 的hook</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useSelector&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> const App =() =&gt; &#123;</span></span><br><span class="line"><span class="string">    const todoList = useSelector((state) =&gt; state.todo)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h5 id="11-5-6-useDispatch"><a href="#11-5-6-useDispatch" class="headerlink" title="11.5.6 useDispatch"></a>11.5.6 useDispatch</h5><p>概述：返回 dispatch 函数的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useDispatch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const App =() =&gt; &#123;</span></span><br><span class="line"><span class="string">    const dispatch = useDispatch()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const onSubmitTodo = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    dispatch(</span></span><br><span class="line"><span class="string">      addTodo(&#123;</span></span><br><span class="line"><span class="string">        text,</span></span><br><span class="line"><span class="string">        id: Date.now(),</span></span><br><span class="line"><span class="string">        flag: false,</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    setText(&#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="11-5-7-redux-thunk"><a href="#11-5-7-redux-thunk" class="headerlink" title="11.5.7 redux-thunk"></a>11.5.7 redux-thunk</h5><p>概述： 因为在 reducer 中只能同步操作，那么要想异步处理 redux 就只能在组件中先进行异步操作，然后成功后再 dispatch。但是会让redux 的逻辑散落在UI中，不易于后期管理。</p>
<p>接用该插件可以实现 dispatch 一个函数，然后在这个函数中处理异步。</p>
<p><code>index.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> mainReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleWares = [</span><br><span class="line">  <span class="comment">// 三方模块通过该中间件注册</span></span><br><span class="line">  thunkMiddleware,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  middleWares.<span class="title function_">push</span>(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redux DevTools 配置</span></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> || compose</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  mainReducer,</span><br><span class="line">  <span class="title function_">composeEnhancers</span>(<span class="title function_">applyMiddleware</span>(...middleWares))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测redux 的状态变化</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据发生改变&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>userAction.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">LOGIN</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../actionTypes/userActionType&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; loginApi &#125; <span class="keyword">from</span> <span class="string">&#x27;../../http/Api/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步 类似于 Vuex-mutation</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">loginAction</span> = (<span class="params">payload</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">LOGIN</span>,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">loginActionAsync</span> = (<span class="params">payload</span>) =&gt; <span class="function">(<span class="params">dispatch</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">loginApi</span>(payload).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="string">&#x27;200&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="title function_">loginAction</span>(res.<span class="property">data</span>.<span class="property">data</span>))</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登陆失败&#x27;</span>)</span><br><span class="line">        <span class="title function_">reject</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>userReducer.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">LOGIN</span>, <span class="variable constant_">LOGOUT</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../actionTypes/userActionType&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">INIT_STATE</span> = &#123;</span><br><span class="line">  <span class="attr">userId</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">authList</span>: [],</span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">userReducer</span>(<span class="params">state = INIT_STATE, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGIN</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action.<span class="property">payload</span>,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="attr">LOGOUT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">userId</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">authList</span>: [],</span><br><span class="line">        <span class="attr">token</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;                      </span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>reducer/index.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> userReducer <span class="keyword">from</span> <span class="string">&#x27;./userReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">user</span>: userReducer,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loginAction, loginActionAsync &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/actions/userAction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Login</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>()</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onFinish</span> = <span class="keyword">async</span> (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">loginActionAsync</span>(value)).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">navigate</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-React-和-Vue的区别"><a href="#12-React-和-Vue的区别" class="headerlink" title="12. React 和 Vue的区别"></a>12. React 和 Vue的区别</h2><p>相同点：</p>
<ul>
<li>数据驱动视图</li>
<li>组件化思想</li>
<li>都是用虚拟Dom</li>
</ul>
<p>不同点：</p>
<ul>
<li>核心思想不通：<ul>
<li>Vue为渐进式框架，门槛较低，进行数据劫持或者代理</li>
<li>React函数式编程，数据不可变以及单向数据流</li>
</ul>
</li>
<li>组件写法差异：<ul>
<li>Vue单文件组建格式，即html,css,js写在同一个文件</li>
<li>React为html和css都写进js中</li>
</ul>
</li>
<li>diff算法不同：<ul>
<li>react 首先对新集合进行遍历，通过唯一key值来判断新旧集合中是否存在相同的节点，如果没有的话就创建，如果有的话就会将节点在新集合中的位置和老集合中的位置进行比较，如果不同，则进行移动操作，否则就不操作。如果在遍历的过程中，发现在新集合中没有，就会进行删除操作。</li>
<li>Vue新旧集合各有头尾的变量，他们的2各变量相互比较，一共有四种比较方式，如果四种都没匹配，则会匹配key值，借助key值找到可复用的节点，在进行相关操作。</li>
</ul>
</li>
<li>响应式原理不同：</li>
<li><ul>
<li>Vue依赖收集，自动依赖，数据可变。递归监听data中的所有属性，直接修改，当数据改变时，自动找到引用组件重新渲染。</li>
<li>React基于状态手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染，所以React中会需要shouldComponentUpdate这个生命周期函数来进行控制。</li>
</ul>
</li>
</ul>
<h2 id="13-SetState是同步还是异步的"><a href="#13-SetState是同步还是异步的" class="headerlink" title="13. SetState是同步还是异步的"></a>13. SetState是同步还是异步的</h2><p><code>setState </code>是一个异步方法，但是在<code>setTimeout</code>/<code>setInterval</code>等定时器里逃脱了<code>React</code>对他的掌控，变成了同步方法。</p>
<p>实现机制：类似于<code>Vue</code>的<code>$nextTick</code>和浏览器的时间循环机制，每个<code>setState</code>都会被<code>React</code>加入到任务队列当中，多次对同一个state使用setState只会返回最后一次的结果，因为他不是立刻就更新，而是先放在任务队列中，等时机成熟在执行批量更新。而在<code>React</code>18以后，使用了createRoot api后，所有setState都是异步批量执行。</p>
<h2 id="14-React渲染流程"><a href="#14-React渲染流程" class="headerlink" title="14. React渲染流程"></a>14. React渲染流程</h2><p>React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM并不会直接渲染，而是会先转换为fiber，在进行渲染。VDOM转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的。</p>
<h2 id="15-React常用hooks"><a href="#15-React常用hooks" class="headerlink" title="15. React常用hooks"></a>15. React常用hooks</h2><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><ol>
<li><p>创建登录组件</p>
<ul>
<li><p>在component文件夹中创建一个登录组件Login.vue</p>
</li>
<li><p>在路由文件中导入登录组件,并添加路由规则</p>
</li>
<li><pre><code class="js">import Login from &#39;../components/Login.vue&#39; const routes = [ 
//重定向路由（当用户访问/时，会自动定向到登录路由）
&#123; path: &#39;/&#39;, redirect: &#39;/login&#39; &#125;, //登录组件路由 
&#123; path: &#39;/login&#39;, component: Login &#125; 
]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 登录页面基本布局</span><br><span class="line"></span><br><span class="line">   - 因为在安装Element插件时配置的是按需导入，因此需要在plugins文件夹中的element.js文件中导入需要用到的组件，并注册为全局可用</span><br><span class="line"></span><br><span class="line">3. 登录表单数据绑定</span><br><span class="line"></span><br><span class="line">   - 根据在Element官网我们所选择的表单组件中绑定数据的方式去绑定我们需要的数据 给密码框添加`type=&#x27;password&#x27;`属性，将密码隐藏</span><br><span class="line"></span><br><span class="line">4. 登录表单数据验证</span><br><span class="line"></span><br><span class="line">   - 根据在Element官网中Form 组件提供了表单验证的功能，只需给表单绑定 rules 属性，并传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即</span><br><span class="line"></span><br><span class="line">5. 点击重置按钮实现表单重置</span><br><span class="line"></span><br><span class="line">   - 首先通过`ref`给表单添加一个引用对象，之后只要获取到这个引用对象（可以任意命名，只要合法），就可以获取到这个表单的实例对象</span><br><span class="line">   - 给重置按钮添加单机事件，并命名事件处理函数</span><br><span class="line">   - 使用Element官网在Form表单组件中提供的`resetFields`方法（对整个表单进行重置，将所有字段值重置为初始值并移除校验结果）表单实例方法就可以重置表单</span><br><span class="line"></span><br><span class="line">6. 点击登录，对表单数据进行预验证（在发送请求之前）</span><br><span class="line"></span><br><span class="line">   - Form表单组件中提供的`validate`（对整个表单进行校验的方法，参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 promise）表单实例方法就可以对表单进行预验证</span><br><span class="line"></span><br><span class="line">7. 发送登录请求（通过预验证后）</span><br><span class="line"></span><br><span class="line">   - 在入口文件导入`axios`，将其挂载到Vue的原型对象上，并配置请求根路径</span><br><span class="line">   - 在登录事件处理函数中发送请求（异步），使用async/await关键字处理异步代码，返回值是一个对象，其中只有data属性中包含的是有用的服务器返回数据，所以将其解构赋值到一个变量</span><br><span class="line"></span><br><span class="line">8. 告诉用户登录结果</span><br><span class="line"></span><br><span class="line">   - Message 消息提示的组件，在element.js文件中导入需要用到的组件，该组件需要进行全局挂载，而不是全局注册</span><br><span class="line">   - 根据接收到的登录请求返回的状态码来提示用户是否登录成功</span><br><span class="line"></span><br><span class="line">9. 登录成功之后的行为</span><br><span class="line"></span><br><span class="line">   - 将登录成功后，服务器返回的token保存到客户端的sessionStorge中，保持登录状态（sessionStorge和localStorge保存期限不同，sessionStorge在窗口关闭后会删除保存的数据，localStorge没有保存期限）；所有API接口除了登录接口外，都需要登录之后才能访问</span><br><span class="line">   - 通过编程式导航跳转到后台主页，路由地址是/home</span><br><span class="line"></span><br><span class="line">10. 路由导航守卫</span><br><span class="line"></span><br><span class="line">    - 在路由文件中添加导航守卫：如果用户没有登录，用户可以通过直接输入URL地址访问页面，这是不合理的，因此需要重新导航到登录页面</span><br><span class="line"></span><br><span class="line">    - ```js</span><br><span class="line">      // 挂载路由导航守卫</span><br><span class="line">      router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">        // to 代表将要访问的路径</span><br><span class="line">        // from 代表从那个路径跳转而来</span><br><span class="line">        // next 是一个函数，表示是否放行</span><br><span class="line">        // next()  放行   next(&#x27;/login&#x27;)  强制跳转</span><br><span class="line">        if (to.path === &#x27;/login&#x27;) return next()</span><br><span class="line">        // 获取 token </span><br><span class="line">        const tokenStr = window.sessionStorage.getItem(&#x27;token&#x27;)</span><br><span class="line">        if (!tokenStr) return next(&#x27;/login&#x27;)</span><br><span class="line">        next()</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>实现退出功能</p>
<ul>
<li><p>在Home组件中暂时添加一个退出按钮</p>
</li>
<li><p>给按钮绑定单机事件，并命名事件处理函数</p>
</li>
<li><p>定义事件处理函数，基于token实现退出功能只需销毁本地token即可</p>
</li>
<li><pre><code class="js">logout() &#123;
      window.sessionStorage.clear();
      this.$router.push(&quot;/login&quot;);
    &#125;,
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-登录验证"><a href="#1-登录验证" class="headerlink" title="1. 登录验证"></a>1. 登录验证</h3><h3 id="2-项目的优化"><a href="#2-项目的优化" class="headerlink" title="2. 项目的优化"></a>2. 项目的优化</h3><ul>
<li>在可视化的UI面板中查看控制台和分析面板，看到项目中所存在的问题，资源文件和依赖项文件等文件大小是否需要优化</li>
<li>Element-UI组件按需加载</li>
<li>第三方库启用CDN,可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。</li>
<li>路由懒加载，将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。路由懒加载就是只加载你当前点击的那个模块</li>
<li>开启 gzip 配置，减小文件体积，使传输速度更快。<ul>
<li>安装相应包<code>npm install compression -S</code></li>
<li>导入包<code>const compression = require(&#39;compression&#39;);</code></li>
<li>启用中间件<code>app.use(compression());</code></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://793335974.github.io/79333">菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://793335974.github.io/79333/2021/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/">https://793335974.github.io/79333/2021/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://793335974.github.io/79333" target="_blank">野菜收留所</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/79333/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/79333/2021/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="计算机基础笔记"><img class="cover" src="https://api.gumengya.com/Api/FjImg?format=image&amp;_t=3" onerror="onerror=null;src='/79333/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机基础笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-text">1.  html5有什么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-text">2. 如何理解HTML语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-meta%E6%A0%87%E7%AD%BE"><span class="toc-text">3. meta标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4. src 和 href 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-css3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-text">0. css3有什么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">1. CSS选择器及优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-text">2. position 属性的值有哪些及其区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-box-sizing%E5%B1%9E%E6%80%A7"><span class="toc-text">3. box-sizing属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">4. CSS 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BFC%EF%BC%88%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%E5%92%8CIFC-%E8%A1%8C%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B"><span class="toc-text">5. BFC（块级格式上下文）和IFC(行级格式化上下)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">6. 水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-text">自适应两栏布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-text">三栏布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7"><span class="toc-text">7. 用CSS实现三角符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-text">8. 常见的布局类型（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%B5%AE%E5%8A%A8%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-text">9. 浮动（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-text">10. 常见的行内元素和块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-px-em-rem-vw-vh-rpx%E7%AD%89%E5%8D%95%E4%BD%8D%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">11. px,em,rem,vw,vh,rpx等单位的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFDOM%E4%BA%8B%E4%BB%B6%E6%B5%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E6%9F%A5"><span class="toc-text">12. 什么是DOM事件流？什么是事件委托(查)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-text">13. 事件冒泡和事件捕捉有什么区别（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-link%E5%92%8C-import"><span class="toc-text">14. link和@import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">15. 响应式布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81"><span class="toc-text">16. 元素不可见</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-css%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">17. css动画属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-translate-%E5%8F%82%E6%95%B01%EF%BC%8C%E5%8F%82%E6%95%B02-%E2%80%94%E2%80%94%E2%80%94%E4%BD%8D%E7%A7%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">transform:translate(参数1，参数2)———位移属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-scale-%E2%80%94%E2%80%94%E2%80%94-2D%E7%BC%A9%E6%94%BE"><span class="toc-text">transform:scale()———-2D缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-rotate-%E2%80%94%E2%80%94%E2%80%942D%E6%97%8B%E8%BD%AC"><span class="toc-text">transform:rotate()———2D旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation%E5%B1%9E%E6%80%A7"><span class="toc-text">animation属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-name"><span class="toc-text">animation-name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-text">animation-iteration-count</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS"><span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-Object%E5%B8%B8%E7%94%A8%E7%9A%84API"><span class="toc-text">0. Object常用的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="toc-text">2. 数据类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">数据类型转换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">4. 作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-text">5. 什么是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-text">6. this的指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-new-%E5%AE%9E%E7%8E%B0"><span class="toc-text">7. new 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-NaN-NaN%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88"><span class="toc-text">10. NaN &#x3D;&#x3D;&#x3D; NaN返回什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-text">11. 手写call、apply、bind（查）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%89%A7%E8%A1%8C%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">12. 执行栈和执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">13. 原型，原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-JS-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-text">14. JS 中的常用的继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">15. 内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">16. 垃圾回收机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">17. 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">18. js是单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-promise"><span class="toc-text">19. promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-async%E5%92%8Cawait"><span class="toc-text">20. async和await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">21. 宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">22. js执行机制(event loop 事件循环)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">24. 防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9F%A5%EF%BC%89"><span class="toc-text">26. 常用的数组方法（查）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">2. 数组最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">3. 数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">4. 反转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">5. 遍历数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-for-of"><span class="toc-text">1. for of</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-forEach"><span class="toc-text">2. forEach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-some"><span class="toc-text">3. some</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-every"><span class="toc-text">4. every</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-map"><span class="toc-text">5. map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-filter"><span class="toc-text">6. filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-find"><span class="toc-text">7. find()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-bom%E5%92%8Cdom%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">28. bom和dom的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">29. JS性能优化的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-defer-%E5%92%8C-async"><span class="toc-text">30. defer 和 async</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: radial-gradient(circle, rgba(238,174,202,1) 0%, rgba(148,187,233,0.9884746134782038) 100%);"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/79333/js/utils.js"></script><script src="/79333/js/main.js"></script><script src="/79333/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.33"></script><script src="https://npm.elemecdn.com/instant.page/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="9812808059" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrctype="1"> </div><script src="https://npm.elemecdn.com/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="/79333/pluginsSrc/butterfly-extsrc/dist/click-show-text.min.js?v=1.1.3" data-mobile="true" data-text="你好,富强,民主,文明,和谐,自由,平等,公正,法治,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://npm.elemecdn.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/aplayer/dist/APlayer.min.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/theme/meting.min.js"></script><script src="https://npm.elemecdn.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/79333/404.html')
  }
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/79333/js/search/local-search.js"></script></div></div></body></html>